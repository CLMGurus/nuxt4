{"version":3,"file":"extensions_cornerstone-dicom-seg_src_viewports_OHIFCornerstoneSEGViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAIA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAQA;AAAA;AAjQA;AA2BA;AAAA;AAwOA;AACA;AAAA;AAAA;AAEA;AAIA;AAAA;AAAA;AAEA;AAIA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA","sources":["file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/utils/initSEGToolGroup.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/utils/promptHydrateSEG.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/viewports/OHIFCornerstoneSEGViewport.tsx"],"sourcesContent":["function createSEGToolGroupAndAddTools(ToolGroupService, customizationService, toolGroupId) {\n  const tools = customizationService.getCustomization('cornerstone.overlayViewportTools');\n\n  return ToolGroupService.createToolGroupAndAddTools(toolGroupId, tools);\n}\n\nexport default createSEGToolGroupAndAddTools;\n","import { utils, Types } from '@ohif/extension-cornerstone';\n\nfunction promptHydrateSEG({\n  servicesManager,\n  segDisplaySet,\n  viewportId,\n  preHydrateCallbacks,\n  hydrateCallback,\n}: {\n  servicesManager: AppTypes.ServicesManager;\n  segDisplaySet: AppTypes.DisplaySet;\n  viewportId: string;\n  preHydrateCallbacks?: Types.HydrationCallback[];\n  hydrateCallback: Types.HydrationCallback;\n}) {\n  return utils.promptHydrationDialog({\n    servicesManager,\n    viewportId,\n    displaySet: segDisplaySet as AppTypes.DisplaySet,\n    preHydrateCallbacks,\n    hydrateCallback,\n    type: 'SEG',\n  });\n}\n\nexport default promptHydrateSEG;\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useViewportGrid } from '@ohif/ui-next';\nimport createSEGToolGroupAndAddTools from '../utils/initSEGToolGroup';\nimport promptHydrateSEG from '../utils/promptHydrateSEG';\nimport { usePositionPresentationStore, OHIFCornerstoneViewport } from '@ohif/extension-cornerstone';\nimport { SegmentationRepresentations } from '@cornerstonejs/tools/enums';\nimport { useSystem } from '@ohif/core/src/contextProviders/SystemProvider';\n\nconst SEG_TOOLGROUP_BASE_NAME = 'SEGToolGroup';\n\nfunction OHIFCornerstoneSEGViewport(props: withAppTypes) {\n  const { servicesManager, commandsManager } = useSystem();\n  const { children, displaySets, viewportOptions } = props as {\n    children: React.ReactNode;\n    displaySets: AppTypes.DisplaySet[];\n    viewportOptions: AppTypes.ViewportOptions;\n  };\n  const viewportId = viewportOptions.viewportId;\n\n  const { displaySetService, toolGroupService, segmentationService, customizationService } =\n    servicesManager.services;\n\n  const LoadingIndicatorTotalPercent = customizationService.getCustomization(\n    'ui.loadingIndicatorTotalPercent'\n  );\n\n  const toolGroupId = `${SEG_TOOLGROUP_BASE_NAME}-${viewportId}`;\n\n  // SEG viewport will always have a single display set\n  if (displaySets.length > 1) {\n    throw new Error('SEG viewport should only have a single display set');\n  }\n\n  const segDisplaySet = displaySets[0];\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n\n  // States\n  const { setPositionPresentation } = usePositionPresentationStore();\n\n  // Hydration means that the SEG is opened and segments are loaded into the\n  // segmentation panel, and SEG is also rendered on any viewport that is in the\n  // same frameOfReferenceUID as the referencedSeriesUID of the SEG. However,\n  // loading basically means SEG loading over network and bit unpacking of the\n  // SEG data.\n  const [segIsLoading, setSegIsLoading] = useState(!segDisplaySet.isLoaded);\n  const [processingProgress, setProcessingProgress] = useState({\n    percentComplete: null,\n    totalSegments: null,\n  });\n\n  // refs\n  const referencedDisplaySetRef = useRef(null);\n\n  const { viewports, activeViewportId } = viewportGrid;\n\n  const referencedDisplaySetInstanceUID = segDisplaySet.referencedDisplaySetInstanceUID;\n  // If the referencedDisplaySetInstanceUID is not found, it means the SEG series is being\n  // launched without its corresponding referenced display set (e.g., the SEG series is launched using\n  // series launch /mode?StudyInstanceUIDs=&SeriesInstanceUID).\n  // In such cases, we attempt to handle this scenario gracefully by\n  // invoking a custom handler. Ideally, if a user tries to launch a series that isn't viewable,\n  // (eg.: we can prompt them with an explanation and provide a link to the full study).\n  if (!referencedDisplaySetInstanceUID) {\n    const missingReferenceDisplaySetHandler = customizationService.getCustomization(\n      'missingReferenceDisplaySetHandler'\n    );\n    const { handled } = missingReferenceDisplaySetHandler();\n    if (handled) {\n      return;\n    }\n  }\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\n    referencedDisplaySetInstanceUID\n  );\n\n  const referencedDisplaySetMetadata = _getReferencedDisplaySetMetadata(\n    referencedDisplaySet,\n    segDisplaySet\n  );\n\n  referencedDisplaySetRef.current = {\n    displaySet: referencedDisplaySet,\n    metadata: referencedDisplaySetMetadata,\n  };\n\n  const getCornerstoneViewport = useCallback(() => {\n    return (\n      <OHIFCornerstoneViewport\n        {...props}\n        displaySets={[segDisplaySet]}\n        viewportOptions={{\n          viewportType: viewportOptions.viewportType,\n          toolGroupId: toolGroupId,\n          orientation: viewportOptions.orientation,\n          viewportId: viewportOptions.viewportId,\n          presentationIds: viewportOptions.presentationIds,\n        }}\n        onElementEnabled={evt => {\n          props.onElementEnabled?.(evt);\n        }}\n      />\n    );\n  }, [viewportId, segDisplaySet, toolGroupId, props, viewportOptions]);\n\n  useEffect(() => {\n    if (segIsLoading) {\n      return;\n    }\n\n    // if not active viewport, return\n    if (viewportId !== activeViewportId) {\n      return;\n    }\n\n    promptHydrateSEG({\n      servicesManager,\n      viewportId,\n      segDisplaySet,\n      hydrateCallback: async () => {\n        await commandsManager.runCommand('hydrateSecondaryDisplaySet', {\n          displaySet: segDisplaySet,\n          viewportId,\n        });\n\n        return true;\n      },\n    });\n  }, [servicesManager, viewportId, segDisplaySet, segIsLoading, commandsManager, activeViewportId]);\n\n  useEffect(() => {\n    // on new seg display set, remove all segmentations from all viewports\n    segmentationService.clearSegmentationRepresentations(viewportId);\n\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENTATION_LOADING_COMPLETE,\n      evt => {\n        if (evt.segDisplaySet.displaySetInstanceUID === segDisplaySet.displaySetInstanceUID) {\n          setSegIsLoading(false);\n        }\n\n        if (segDisplaySet?.firstSegmentedSliceImageId && viewportOptions?.presentationIds) {\n          const { firstSegmentedSliceImageId } = segDisplaySet;\n          const { presentationIds } = viewportOptions;\n\n          setPositionPresentation(presentationIds.positionPresentationId, {\n            viewReference: {\n              referencedImageId: firstSegmentedSliceImageId,\n            },\n          });\n        }\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [segDisplaySet]);\n\n  useEffect(() => {\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE,\n      ({ percentComplete, numSegments }) => {\n        setProcessingProgress({\n          percentComplete,\n          totalSegments: numSegments,\n        });\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [segDisplaySet]);\n\n  /**\n   Cleanup the SEG viewport when the viewport is destroyed\n   */\n  useEffect(() => {\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\n      ({ displaySetInstanceUIDs }) => {\n        const activeViewport = viewports.get(activeViewportId);\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\n          viewportGridService.setDisplaySetsForViewport({\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [],\n          });\n        }\n      }\n    );\n\n    return () => {\n      onDisplaySetsRemovedSubscription.unsubscribe();\n    };\n  }, []);\n\n  useEffect(() => {\n    let toolGroup = toolGroupService.getToolGroup(toolGroupId);\n\n    if (toolGroup) {\n      return;\n    }\n\n    // keep the already stored segmentationPresentation for this viewport in memory\n    // so that we can restore it after hydrating the SEG\n    commandsManager.runCommand('updateStoredSegmentationPresentation', {\n      displaySet: segDisplaySet,\n      type: SegmentationRepresentations.Labelmap,\n    });\n\n    // always start fresh for this viewport since it is special type of viewport\n    // that should only show one segmentation at a time.\n    segmentationService.clearSegmentationRepresentations(viewportId);\n\n    // This creates a custom tool group which has the lifetime of this view\n    // only, and does NOT interfere with currently displayed segmentations.\n    toolGroup = createSEGToolGroupAndAddTools(toolGroupService, customizationService, toolGroupId);\n\n    return () => {\n      // remove the segmentation representations if seg displayset changed\n      // e.g., another seg displayset is dragged into the viewport\n      segmentationService.clearSegmentationRepresentations(viewportId);\n\n      // Only destroy the viewport specific implementation\n      toolGroupService.destroyToolGroup(toolGroupId);\n    };\n  }, []);\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  let childrenWithProps = null;\n\n  if (\n    !referencedDisplaySetRef.current ||\n    referencedDisplaySet.displaySetInstanceUID !==\n      referencedDisplaySetRef.current.displaySet.displaySetInstanceUID\n  ) {\n    return null;\n  }\n\n  if (children && children.length) {\n    childrenWithProps = children.map((child, index) => {\n      return (\n        child &&\n        React.cloneElement(child, {\n          viewportId,\n          key: index,\n        })\n      );\n    });\n  }\n\n  return (\n    <>\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {segIsLoading && (\n          <LoadingIndicatorTotalPercent\n            className=\"h-full w-full\"\n            totalNumbers={processingProgress.totalSegments}\n            percentComplete={processingProgress.percentComplete}\n            loadingText=\"Loading SEG...\"\n          />\n        )}\n        {getCornerstoneViewport()}\n        {childrenWithProps}\n      </div>\n    </>\n  );\n}\n\nfunction _getReferencedDisplaySetMetadata(referencedDisplaySet, segDisplaySet) {\n  const { SharedFunctionalGroupsSequence } = segDisplaySet.instance;\n\n  const SharedFunctionalGroup = Array.isArray(SharedFunctionalGroupsSequence)\n    ? SharedFunctionalGroupsSequence[0]\n    : SharedFunctionalGroupsSequence;\n\n  const { PixelMeasuresSequence } = SharedFunctionalGroup;\n\n  const PixelMeasures = Array.isArray(PixelMeasuresSequence)\n    ? PixelMeasuresSequence[0]\n    : PixelMeasuresSequence;\n\n  const { SpacingBetweenSlices, SliceThickness } = PixelMeasures;\n\n  const image0 = referencedDisplaySet.images[0];\n  const referencedDisplaySetMetadata = {\n    PatientID: image0.PatientID,\n    PatientName: image0.PatientName,\n    PatientSex: image0.PatientSex,\n    PatientAge: image0.PatientAge,\n    SliceThickness: image0.SliceThickness || SliceThickness,\n    StudyDate: image0.StudyDate,\n    SeriesDescription: image0.SeriesDescription,\n    SeriesInstanceUID: image0.SeriesInstanceUID,\n    SeriesNumber: image0.SeriesNumber,\n    ManufacturerModelName: image0.ManufacturerModelName,\n    SpacingBetweenSlices: image0.SpacingBetweenSlices || SpacingBetweenSlices,\n  };\n\n  return referencedDisplaySetMetadata;\n}\n\nexport default OHIFCornerstoneSEGViewport;\n"],"names":[],"sourceRoot":""}