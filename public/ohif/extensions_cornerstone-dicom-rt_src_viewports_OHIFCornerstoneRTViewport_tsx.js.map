{"version":3,"file":"extensions_cornerstone-dicom-rt_src_viewports_OHIFCornerstoneRTViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAQA;AAAA;AA9NA;AA6BA;AAAA;AAmMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA","sources":["file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-rt/src/utils/initRTToolGroup.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-rt/src/utils/promptHydrateRT.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-rt/src/viewports/OHIFCornerstoneRTViewport.tsx"],"sourcesContent":["function createRTToolGroupAndAddTools(ToolGroupService, customizationService, toolGroupId) {\n  const tools = customizationService.getCustomization('cornerstone.overlayViewportTools');\n\n  return ToolGroupService.createToolGroupAndAddTools(toolGroupId, tools);\n}\n\nexport default createRTToolGroupAndAddTools;\n","import { utils, Types } from '@ohif/extension-cornerstone';\n\nfunction promptHydrateRT({\n  servicesManager,\n  rtDisplaySet,\n  viewportId,\n  preHydrateCallbacks,\n  hydrateRTDisplaySet,\n}: {\n  servicesManager: AppTypes.ServicesManager;\n  rtDisplaySet: AppTypes.DisplaySet;\n  viewportId: string;\n  preHydrateCallbacks?: Types.HydrationCallback[];\n  hydrateRTDisplaySet: Types.HydrationCallback;\n}) {\n  return utils.promptHydrationDialog({\n    servicesManager,\n    viewportId,\n    displaySet: rtDisplaySet,\n    preHydrateCallbacks,\n    hydrateCallback: hydrateRTDisplaySet,\n    type: 'RTSTRUCT',\n  });\n}\n\nexport default promptHydrateRT;\n","import React, { Component, useCallback, useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useViewportGrid } from '@ohif/ui-next';\nimport {\n  utils,\n  usePositionPresentationStore,\n  OHIFCornerstoneViewport,\n} from '@ohif/extension-cornerstone';\n\nimport promptHydrateRT from '../utils/promptHydrateRT';\nimport createRTToolGroupAndAddTools from '../utils/initRTToolGroup';\nimport { useSystem } from '@ohif/core/src';\nconst RT_TOOLGROUP_BASE_NAME = 'RTToolGroup';\n\nfunction OHIFCornerstoneRTViewport(props: withAppTypes) {\n  const { servicesManager, commandsManager } = useSystem();\n  const { children, displaySets, viewportOptions } = props as {\n    children: React.ReactNode;\n    displaySets: AppTypes.DisplaySet[];\n    viewportOptions: AppTypes.ViewportOptions;\n  };\n\n  const { displaySetService, toolGroupService, segmentationService, customizationService } =\n    servicesManager.services;\n\n  const viewportId = viewportOptions.viewportId;\n\n  const toolGroupId = `${RT_TOOLGROUP_BASE_NAME}-${viewportId}`;\n\n  // RT viewport will always have a single display set\n  if (displaySets.length > 1) {\n    throw new Error('RT viewport should only have a single display set');\n  }\n\n  const LoadingIndicatorTotalPercent = customizationService.getCustomization(\n    'ui.loadingIndicatorTotalPercent'\n  );\n\n  const rtDisplaySet = displaySets[0];\n\n  const [{ viewports, activeViewportId }, viewportGridService] = useViewportGrid();\n\n  // States\n  const { setPositionPresentation } = usePositionPresentationStore();\n  const [rtIsLoading, setRtIsLoading] = useState(!rtDisplaySet.isLoaded);\n  const [processingProgress, setProcessingProgress] = useState({\n    percentComplete: null,\n    totalSegments: null,\n  });\n\n  const referencedDisplaySetRef = useRef(null);\n\n  const referencedDisplaySetInstanceUID = rtDisplaySet.referencedDisplaySetInstanceUID;\n  // If the referencedDisplaySetInstanceUID is not found, it means the RTStruct series is being\n  // launched without its corresponding referenced display set (e.g., the RTStruct series is launched using\n  // series launch /mode?StudyInstanceUIDs=&SeriesInstanceUID).\n  // In such cases, we attempt to handle this scenario gracefully by\n  // invoking a custom handler. Ideally, if a user tries to launch a series that isn't viewable,\n  // (eg.: we can prompt them with an explanation and provide a link to the full study).\n  if (!referencedDisplaySetInstanceUID) {\n    const missingReferenceDisplaySetHandler = customizationService.getCustomization(\n      'missingReferenceDisplaySetHandler'\n    );\n    const { handled } = missingReferenceDisplaySetHandler();\n    if (handled) {\n      return;\n    }\n  }\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\n    referencedDisplaySetInstanceUID\n  );\n  const referencedDisplaySetMetadata = _getReferencedDisplaySetMetadata(referencedDisplaySet);\n\n  referencedDisplaySetRef.current = {\n    displaySet: referencedDisplaySet,\n    metadata: referencedDisplaySetMetadata,\n  };\n\n  useEffect(() => {\n    if (rtIsLoading) {\n      return;\n    }\n\n    // if not active viewport, return\n    if (viewportId !== activeViewportId) {\n      return;\n    }\n\n    promptHydrateRT({\n      servicesManager,\n      viewportId,\n      rtDisplaySet,\n      hydrateRTDisplaySet: async () => {\n        return commandsManager.runCommand('hydrateSecondaryDisplaySet', {\n          displaySet: rtDisplaySet,\n          viewportId,\n        });\n      },\n    });\n  }, [servicesManager, viewportId, rtDisplaySet, rtIsLoading, commandsManager, activeViewportId]);\n\n  useEffect(() => {\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENTATION_LOADING_COMPLETE,\n      evt => {\n        if (evt.rtDisplaySet.displaySetInstanceUID === rtDisplaySet.displaySetInstanceUID) {\n          setRtIsLoading(false);\n        }\n\n        if (rtDisplaySet?.firstSegmentedSliceImageId && viewportOptions?.presentationIds) {\n          const { firstSegmentedSliceImageId } = rtDisplaySet;\n          const { presentationIds } = viewportOptions;\n\n          setPositionPresentation(presentationIds.positionPresentationId, {\n            viewportType: 'stack',\n            viewReference: {\n              referencedImageId: firstSegmentedSliceImageId,\n            },\n            viewPresentation: {},\n          });\n        }\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [rtDisplaySet]);\n\n  useEffect(() => {\n    const segmentLoadingSubscription = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE,\n      ({ percentComplete, numSegments }) => {\n        setProcessingProgress({\n          percentComplete,\n          totalSegments: numSegments,\n        });\n      }\n    );\n\n    const displaySetsRemovedSubscription = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\n      ({ displaySetInstanceUIDs }) => {\n        const activeViewport = viewports.get(activeViewportId);\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\n          viewportGridService.setDisplaySetsForViewport({\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [],\n          });\n        }\n      }\n    );\n\n    return () => {\n      segmentLoadingSubscription.unsubscribe();\n      displaySetsRemovedSubscription.unsubscribe();\n    };\n  }, [rtDisplaySet, displaySetService, viewports, activeViewportId, viewportGridService]);\n\n  useEffect(() => {\n    let toolGroup = toolGroupService.getToolGroup(toolGroupId);\n\n    if (toolGroup) {\n      return;\n    }\n\n    toolGroup = createRTToolGroupAndAddTools(toolGroupService, customizationService, toolGroupId);\n\n    return () => {\n      // remove the segmentation representations if seg displayset changed\n      segmentationService.removeSegmentationRepresentations(viewportId);\n      referencedDisplaySetRef.current = null;\n      toolGroupService.destroyToolGroup(toolGroupId);\n    };\n  }, []);\n\n  const getCornerstoneViewport = useCallback(() => {\n    const { displaySet: referencedDisplaySet } = referencedDisplaySetRef.current;\n\n    // Todo: jump to the center of the first segment\n    return (\n      <OHIFCornerstoneViewport\n        {...props}\n        displaySets={[referencedDisplaySet, rtDisplaySet]}\n        viewportOptions={{\n          viewportType: viewportOptions.viewportType,\n          toolGroupId: toolGroupId,\n          orientation: viewportOptions.orientation,\n          viewportId: viewportOptions.viewportId,\n          presentationIds: viewportOptions.presentationIds,\n        }}\n        onElementEnabled={evt => {\n          props.onElementEnabled?.(evt);\n        }}\n      />\n    );\n  }, [viewportId, rtDisplaySet, toolGroupId]);\n\n  let childrenWithProps = null;\n\n  if (\n    !referencedDisplaySetRef.current ||\n    referencedDisplaySet.displaySetInstanceUID !==\n      referencedDisplaySetRef.current.displaySet.displaySetInstanceUID\n  ) {\n    return null;\n  }\n\n  if (children && children.length) {\n    childrenWithProps = children.map((child, index) => {\n      return (\n        child &&\n        React.cloneElement(child, {\n          viewportId,\n          key: index,\n        })\n      );\n    });\n  }\n\n  return (\n    <>\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {rtIsLoading && (\n          <LoadingIndicatorTotalPercent\n            className=\"h-full w-full\"\n            totalNumbers={processingProgress.totalSegments}\n            percentComplete={processingProgress.percentComplete}\n            loadingText=\"Loading RTSTRUCT...\"\n          />\n        )}\n        {getCornerstoneViewport()}\n        {childrenWithProps}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneRTViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n};\n\nfunction _getReferencedDisplaySetMetadata(referencedDisplaySet) {\n  const image0 = referencedDisplaySet.images[0];\n  const referencedDisplaySetMetadata = {\n    PatientID: image0.PatientID,\n    PatientName: image0.PatientName,\n    PatientSex: image0.PatientSex,\n    PatientAge: image0.PatientAge,\n    SliceThickness: image0.SliceThickness,\n    StudyDate: image0.StudyDate,\n    SeriesDescription: image0.SeriesDescription,\n    SeriesInstanceUID: image0.SeriesInstanceUID,\n    SeriesNumber: image0.SeriesNumber,\n    ManufacturerModelName: image0.ManufacturerModelName,\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\n  };\n\n  return referencedDisplaySetMetadata;\n}\n\nexport default OHIFCornerstoneRTViewport;\n"],"names":[],"sourceRoot":""}