{"version":3,"file":"extensions_cornerstone-dicom-seg_src_index_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAMA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AAEA;AACA;AAKA;AAEA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AAEA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAKA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7PA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvEA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAIA;;AAEA;AACA;AACA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAIA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA","sources":["file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/commandsModule.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/getToolbarModule.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/id.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/index.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts"],"sourcesContent":["import dcmjs from 'dcmjs';\nimport { classes, Types } from '@ohif/core';\nimport { cache, metaData } from '@cornerstonejs/core';\nimport { segmentation as cornerstoneToolsSegmentation } from '@cornerstonejs/tools';\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\nimport { createReportDialogPrompt } from '@ohif/extension-default';\nimport { DicomMetadataStore } from '@ohif/core';\n\nimport PROMPT_RESPONSES from '../../default/src/utils/_shared/PROMPT_RESPONSES';\n\nconst { datasetToBlob } = dcmjs.data;\n\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\n  const { viewports, activeViewportId } = viewportGridService.getState();\n  const targetViewportId = viewportId || activeViewportId;\n\n  const viewport = viewports.get(targetViewportId);\n\n  return viewport;\n};\n\nconst {\n  Cornerstone3D: {\n    Segmentation: { generateSegmentation },\n  },\n} = adaptersSEG;\n\nconst {\n  Cornerstone3D: {\n    RTSS: { generateRTSSFromSegmentations },\n  },\n} = adaptersRT;\n\nconst { downloadDICOMData } = helpers;\n\nconst commandsModule = ({\n  servicesManager,\n  extensionManager,\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\n  const { segmentationService, displaySetService, viewportGridService, toolGroupService } =\n    servicesManager.services as AppTypes.Services;\n\n  const actions = {\n    /**\n     * Loads segmentations for a specified viewport.\n     * The function prepares the viewport for rendering, then loads the segmentation details.\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentations - Array of segmentations to be loaded.\n     * @param params.viewportId - the target viewport ID.\n     *\n     */\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\n      // Todo: handle adding more than one segmentation\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\n\n      const segmentation = segmentations[0];\n      const segmentationId = segmentation.segmentationId;\n      const label = segmentation.config.label;\n      const segments = segmentation.config.segments;\n\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n      await segmentationService.createLabelmapForDisplaySet(displaySet, {\n        segmentationId,\n        segments,\n        label,\n      });\n\n      segmentationService.addOrUpdateSegmentation(segmentation);\n\n      await segmentationService.addSegmentationRepresentation(viewport.viewportId, {\n        segmentationId,\n      });\n\n      return segmentationId;\n    },\n    /**\n     * Generates a segmentation from a given segmentation ID.\n     * This function retrieves the associated segmentation and\n     * its referenced volume, extracts label maps from the\n     * segmentation volume, and produces segmentation data\n     * alongside associated metadata.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be generated.\n     * @param params.options - Optional configuration for the generation process.\n     *\n     * @returns Returns the generated segmentation data.\n     */\n    generateSegmentation: ({ segmentationId, options = {} }) => {\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\n\n      const { imageIds } = segmentation.representationData.Labelmap;\n\n      const segImages = imageIds.map(imageId => cache.getImage(imageId));\n      const referencedImages = segImages.map(image => cache.getImage(image.referencedImageId));\n\n      const labelmaps2D = [];\n\n      let z = 0;\n\n      for (const segImage of segImages) {\n        const segmentsOnLabelmap = new Set();\n        const pixelData = segImage.getPixelData();\n        const { rows, columns } = segImage;\n\n        // Use a single pass through the pixel data\n        for (let i = 0; i < pixelData.length; i++) {\n          const segment = pixelData[i];\n          if (segment !== 0) {\n            segmentsOnLabelmap.add(segment);\n          }\n        }\n\n        labelmaps2D[z++] = {\n          segmentsOnLabelmap: Array.from(segmentsOnLabelmap),\n          pixelData,\n          rows,\n          columns,\n        };\n      }\n\n      const allSegmentsOnLabelmap = labelmaps2D.map(labelmap => labelmap.segmentsOnLabelmap);\n\n      const labelmap3D = {\n        segmentsOnLabelmap: Array.from(new Set(allSegmentsOnLabelmap.flat())),\n        metadata: [],\n        labelmaps2D,\n      };\n\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      const representations = segmentationService.getRepresentationsForSegmentation(segmentationId);\n\n      Object.entries(segmentationInOHIF.segments).forEach(([segmentIndex, segment]) => {\n        // segmentation service already has a color for each segment\n        if (!segment) {\n          return;\n        }\n\n        const { label } = segment;\n\n        const firstRepresentation = representations[0];\n        const color = segmentationService.getSegmentColor(\n          firstRepresentation.viewportId,\n          segmentationId,\n          segment.segmentIndex\n        );\n\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\n          color.slice(0, 3).map(value => value / 255)\n        ).map(value => Math.round(value));\n\n        const segmentMetadata = {\n          SegmentNumber: segmentIndex.toString(),\n          SegmentLabel: label,\n          SegmentAlgorithmType: segment?.algorithmType || 'MANUAL',\n          SegmentAlgorithmName: segment?.algorithmName || 'OHIF Brush',\n          RecommendedDisplayCIELabValue,\n          SegmentedPropertyCategoryCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n          SegmentedPropertyTypeCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n        };\n        labelmap3D.metadata[segmentIndex] = segmentMetadata;\n      });\n\n      const generatedSegmentation = generateSegmentation(\n        referencedImages,\n        labelmap3D,\n        metaData,\n        options\n      );\n\n      return generatedSegmentation;\n    },\n    /**\n     * Downloads a segmentation based on the provided segmentation ID.\n     * This function retrieves the associated segmentation and\n     * uses it to generate the corresponding DICOM dataset, which\n     * is then downloaded with an appropriate filename.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\n     *\n     */\n    downloadSegmentation: ({ segmentationId }) => {\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      const generatedSegmentation = actions.generateSegmentation({\n        segmentationId,\n      });\n\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\n    },\n    /**\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\n     * and in its absence, defaults to 'Research Derived Series'.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be stored.\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\n     *\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\n     * otherwise throws an error.\n     */\n    storeSegmentation: async ({ segmentationId, dataSource }) => {\n      const segmentation = segmentationService.getSegmentation(segmentationId);\n\n      if (!segmentation) {\n        throw new Error('No segmentation found');\n      }\n\n      const { label } = segmentation;\n      const defaultDataSource = dataSource ?? extensionManager.getActiveDataSource()[0];\n\n      const {\n        value: reportName,\n        dataSourceName: selectedDataSource,\n        action,\n      } = await createReportDialogPrompt({\n        servicesManager,\n        extensionManager,\n        title: 'Store Segmentation',\n      });\n\n      if (action === PROMPT_RESPONSES.CREATE_REPORT) {\n        try {\n          const selectedDataSourceConfig = selectedDataSource\n            ? extensionManager.getDataSources(selectedDataSource)[0]\n            : defaultDataSource;\n\n          const generatedData = actions.generateSegmentation({\n            segmentationId,\n            options: {\n              SeriesDescription: reportName || label || 'Research Derived Series',\n            },\n          });\n\n          if (!generatedData || !generatedData.dataset) {\n            throw new Error('Error during segmentation generation');\n          }\n\n          const { dataset: naturalizedReport } = generatedData;\n\n          // DCMJS assigns a dummy study id during creation, and this can cause problems, so clearing it out\n          if (naturalizedReport.StudyID === 'No Study ID') {\n            naturalizedReport.StudyID = '';\n          }\n\n          await selectedDataSourceConfig.store.dicom(naturalizedReport);\n\n          // add the information for where we stored it to the instance as well\n          naturalizedReport.wadoRoot = selectedDataSourceConfig.getConfig().wadoRoot;\n\n          DicomMetadataStore.addInstances([naturalizedReport], true);\n\n          return naturalizedReport;\n        } catch (error) {\n          console.debug('Error storing segmentation:', error);\n          throw error;\n        }\n      }\n    },\n    /**\n     * Converts segmentations into RTSS for download.\n     * This sample function retrieves all segentations and passes to\n     * cornerstone tool adapter to convert to DICOM RTSS format. It then\n     * converts dataset to downloadable blob.\n     *\n     */\n    downloadRTSS: async ({ segmentationId }) => {\n      const segmentations = segmentationService.getSegmentation(segmentationId);\n\n      // inject colors to the segmentIndex\n      const firstRepresentation =\n        segmentationService.getRepresentationsForSegmentation(segmentationId)[0];\n      Object.entries(segmentations.segments).forEach(([segmentIndex, segment]) => {\n        segment.color = segmentationService.getSegmentColor(\n          firstRepresentation.viewportId,\n          segmentationId,\n          segmentIndex\n        );\n      });\n\n      const RTSS = await generateRTSSFromSegmentations(\n        segmentations,\n        classes.MetadataProvider,\n        DicomMetadataStore\n      );\n\n      try {\n        const reportBlob = datasetToBlob(RTSS);\n\n        //Create a URL for the binary.\n        const objectUrl = URL.createObjectURL(reportBlob);\n        window.location.assign(objectUrl);\n      } catch (e) {\n        console.warn(e);\n      }\n    },\n  };\n\n  const definitions = {\n    loadSegmentationsForViewport: {\n      commandFn: actions.loadSegmentationsForViewport,\n    },\n\n    generateSegmentation: {\n      commandFn: actions.generateSegmentation,\n    },\n    downloadSegmentation: {\n      commandFn: actions.downloadSegmentation,\n    },\n    storeSegmentation: {\n      commandFn: actions.storeSegmentation,\n    },\n    downloadRTSS: {\n      commandFn: actions.downloadRTSS,\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'SEGMENTATION',\n  };\n};\n\nexport default commandsModule;\n","import { Types } from '@ohif/core';\n\nconst segProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/seg',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  name: 'Segmentations',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n      syncGroups: [\n        {\n          type: 'hydrateseg',\n          id: 'sameFORId',\n          source: true,\n          target: true,\n          // options: {\n          //   matchingRules: ['sameFOR'],\n          // },\n        },\n      ],\n    },\n    displaySets: [\n      {\n        id: 'segDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    segDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SEG',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'Segmentations',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            allowUnmatchedView: true,\n            syncGroups: [\n              {\n                type: 'hydrateseg',\n                id: 'sameFORId',\n                source: true,\n                target: true,\n                // options: {\n                //   matchingRules: ['sameFOR'],\n                // },\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'segDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: segProtocol.id,\n      protocol: segProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { segProtocol };\n","import { utils, Types as OhifTypes } from '@ohif/core';\nimport i18n from '@ohif/i18n';\nimport { metaData, eventTarget } from '@cornerstonejs/core';\nimport { CONSTANTS, segmentation as cstSegmentation } from '@cornerstonejs/tools';\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\n\nimport { SOPClassHandlerId } from './id';\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\n\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4', '1.2.840.10008.5.1.4.1.1.66.7'];\n\nconst loadPromises = {};\n\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager\n) {\n  const instance = instances[0];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPClassUID,\n    wadoRoot,\n    wadoUri,\n    wadoUriRoot,\n  } = instance;\n\n  const displaySet = {\n    Modality: 'SEG',\n    loading: false,\n    isReconstructable: false,\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    referencedImages: null,\n    referencedSeriesInstanceUID: null,\n    referencedDisplaySetInstanceUID: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isHydrated: false,\n    segments: {},\n    sopClassUids,\n    instance,\n    instances: [instance],\n    wadoRoot,\n    wadoUriRoot,\n    wadoUri,\n    isOverlayDisplaySet: true,\n    label: SeriesDescription || `${i18n.t('Series')} ${SeriesNumber} - ${i18n.t('SEG')}`,\n  };\n\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\n\n  if (!referencedSeriesSequence) {\n    console.error('ReferencedSeriesSequence is missing for the SEG');\n    return;\n  }\n\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\n\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\n  const { displaySetService } = servicesManager.services;\n  const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\n    displaySet.referencedSeriesInstanceUID\n  );\n\n  const referencedDisplaySet = referencedDisplaySets[0];\n\n  if (!referencedDisplaySet) {\n    // subscribe to display sets added which means at some point it will be available\n    const { unsubscribe } = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_ADDED,\n      ({ displaySetsAdded }) => {\n        // here we can also do a little bit of search, since sometimes DICOM SEG\n        // does not contain the referenced display set uid , and we can just\n        // see which of the display sets added is more similar and assign it\n        // to the referencedDisplaySet\n        const addedDisplaySet = displaySetsAdded[0];\n        if (addedDisplaySet.SeriesInstanceUID === displaySet.referencedSeriesInstanceUID) {\n          displaySet.referencedDisplaySetInstanceUID = addedDisplaySet.displaySetInstanceUID;\n          displaySet.isReconstructable = addedDisplaySet.isReconstructable;\n          unsubscribe();\n        }\n      }\n    );\n  } else {\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\n    displaySet.isReconstructable = referencedDisplaySet.isReconstructable;\n  }\n\n  displaySet.load = async ({ headers }) =>\n    await _load(displaySet, servicesManager, extensionManager, headers);\n\n  return [displaySet];\n}\n\nfunction _load(\n  segDisplaySet,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager,\n  headers\n) {\n  const { SOPInstanceUID } = segDisplaySet;\n  const { segmentationService } = servicesManager.services;\n\n  if (\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\n    loadPromises[SOPInstanceUID] &&\n    _segmentationExists(segDisplaySet)\n  ) {\n    return loadPromises[SOPInstanceUID];\n  }\n\n  segDisplaySet.loading = true;\n\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\n  // and also return the same promise to any other callers.\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\n      try {\n        await _loadSegments({\n          extensionManager,\n          servicesManager,\n          segDisplaySet,\n          headers,\n        });\n      } catch (e) {\n        segDisplaySet.loading = false;\n        return reject(e);\n      }\n    }\n\n    segmentationService\n      .createSegmentationForSEGDisplaySet(segDisplaySet)\n      .then(() => {\n        segDisplaySet.loading = false;\n        resolve();\n      })\n      .catch(error => {\n        segDisplaySet.loading = false;\n        reject(error);\n      });\n  });\n\n  return loadPromises[SOPInstanceUID];\n}\n\nasync function _loadSegments({\n  extensionManager,\n  servicesManager,\n  segDisplaySet,\n  headers,\n}: withAppTypes) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  const { segmentationService, uiNotificationService } = servicesManager.services;\n\n  const { dicomLoaderService } = utilityModule.exports;\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\n\n  const referencedDisplaySet = servicesManager.services.displaySetService.getDisplaySetByUID(\n    segDisplaySet.referencedDisplaySetInstanceUID\n  );\n\n  if (!referencedDisplaySet) {\n    throw new Error('referencedDisplaySet is missing for SEG');\n  }\n\n  let { imageIds } = referencedDisplaySet;\n\n  if (!imageIds) {\n    // try images\n    const { images } = referencedDisplaySet;\n    imageIds = images.map(image => image.imageId);\n  }\n\n  // Todo: what should be defaults here\n  const tolerance = 0.001;\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\n    const { percentComplete } = evt.detail;\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\n      percentComplete,\n    });\n  });\n\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.createFromDICOMSegBuffer(\n    imageIds,\n    arrayBuffer,\n    { metadataProvider: metaData, tolerance }\n  );\n\n  let usedRecommendedDisplayCIELabValue = true;\n  results.segMetadata.data.forEach((data, i) => {\n    if (i > 0) {\n      data.rgba = data.RecommendedDisplayCIELabValue;\n\n      if (data.rgba) {\n        data.rgba = dicomlabToRGB(data.rgba);\n      } else {\n        usedRecommendedDisplayCIELabValue = false;\n        data.rgba = CONSTANTS.COLOR_LUT[i % CONSTANTS.COLOR_LUT.length];\n      }\n    }\n  });\n\n  if (!usedRecommendedDisplayCIELabValue) {\n    // Display a notification about the non-utilization of RecommendedDisplayCIELabValue\n    uiNotificationService.show({\n      title: 'DICOM SEG import',\n      message:\n        'RecommendedDisplayCIELabValue not found for one or more segments. The default color was used instead.',\n      type: 'warning',\n      duration: 5000,\n    });\n  }\n\n  Object.assign(segDisplaySet, results);\n}\n\nfunction _segmentationExists(segDisplaySet) {\n  return cstSegmentation.state.getSegmentation(segDisplaySet.displaySetInstanceUID);\n}\n\nfunction getSopClassHandlerModule(params: OhifTypes.Extensions.ExtensionParams) {\n  const { servicesManager, extensionManager } = params;\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\n  };\n\n  return [\n    {\n      name: 'dicom-seg',\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","export function getToolbarModule({ servicesManager }: withAppTypes) {\n  const { segmentationService, toolbarService, toolGroupService } = servicesManager.services;\n  return [\n    {\n      name: 'evaluate.cornerstone.hasSegmentation',\n      evaluate: ({ viewportId }) => {\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\n        return {\n          disabled: !segmentations?.length,\n        };\n      },\n    },\n    {\n      name: 'evaluate.cornerstone.segmentation',\n      evaluate: ({ viewportId, button, toolNames, disabledText }) => {\n        // Todo: we need to pass in the button section Id since we are kind of\n        // forcing the button to have black background since initially\n        // it is designed for the toolbox not the toolbar on top\n        // we should then branch the buttonSectionId to have different styles\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\n        if (!segmentations?.length) {\n          return {\n            disabled: true,\n            disabledText: disabledText ?? 'No segmentations available',\n          };\n        }\n\n        const activeSegmentation = segmentationService.getActiveSegmentation(viewportId);\n        if (!Object.keys(activeSegmentation.segments).length) {\n          return {\n            disabled: true,\n            disabledText: 'Add segment to enable this tool',\n          };\n        }\n\n        const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\n\n        if (!toolGroup) {\n          return {\n            disabled: true,\n            disabledText: disabledText ?? 'Not available on the current viewport',\n          };\n        }\n\n        if (!toolNames) {\n          return {\n            disabled: false,\n            // isActive: false,\n          };\n        }\n\n        const toolName = toolbarService.getToolNameForButton(button);\n\n        if (!toolGroup.hasTool(toolName) && !toolNames) {\n          return {\n            disabled: true,\n            disabledText: disabledText ?? 'Not available on the current viewport',\n          };\n        }\n\n        const isPrimaryActive = toolNames\n          ? toolNames.includes(toolGroup.getActivePrimaryMouseButtonTool())\n          : toolGroup.getActivePrimaryMouseButtonTool() === toolName;\n\n        return {\n          disabled: false,\n          isActive: isPrimaryActive,\n        };\n      },\n    },\n  ];\n}\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dicom-seg';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\n","import { id } from './id';\nimport React from 'react';\n\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport getCommandsModule from './commandsModule';\nimport { getToolbarModule } from './getToolbarModule';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\n});\n\nconst OHIFCornerstoneSEGViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n  getCommandsModule,\n  getToolbarModule,\n  getViewportModule({ servicesManager, extensionManager, commandsManager }) {\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\n      return (\n        <OHIFCornerstoneSEGViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          commandsManager={commandsManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\n  },\n  /**\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\n   * Examples include the default sop class handler provided by the default extension\n   */\n  getSopClassHandlerModule,\n  getHangingProtocolModule,\n};\n\nexport default extension;\n","import dcmjs from 'dcmjs';\n\n/**\n * Converts a CIELAB color to an RGB color using the dcmjs library.\n * @param cielab - The CIELAB color to convert.\n * @returns The RGB color as an array of three integers between 0 and 255.\n */\nfunction dicomlabToRGB(cielab: number[]): number[] {\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n\n  return rgb;\n}\n\nexport { dicomlabToRGB };\n"],"names":[],"sourceRoot":""}