{"version":3,"file":"extensions_measurement-tracking_src_viewports_TrackedCornerstoneViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAIA;AAAA;AAtMA;AAeA;AAAA;AAyLA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAGA;AAEA;AAAA;AAAA","sources":["file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/viewports/TrackedCornerstoneViewport.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { ViewportActionArrows } from '@ohif/ui-next';\nimport { OHIFCornerstoneViewport } from '@ohif/extension-cornerstone';\n\nimport { annotation } from '@cornerstonejs/tools';\nimport { useTrackedMeasurements } from './../getContextModule';\nimport { BaseVolumeViewport, Enums } from '@cornerstonejs/core';\nimport { useSystem } from '@ohif/core';\n\nfunction TrackedCornerstoneViewport(\n  props: withAppTypes<{ viewportId: string; displaySets: AppTypes.DisplaySet[] }>\n) {\n  const { servicesManager } = useSystem();\n  const { displaySets, viewportId } = props as {\n    displaySets: AppTypes.DisplaySet[];\n    viewportId: string;\n    servicesManager: AppTypes.Services;\n  };\n\n  const { measurementService, cornerstoneViewportService, viewportGridService, toolbarService } =\n    servicesManager.services;\n\n  // Todo: handling more than one displaySet on the same viewport\n  const displaySet = displaySets[0];\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\n\n  const [isTracked, setIsTracked] = useState(false);\n  const [trackedMeasurementUID, setTrackedMeasurementUID] = useState(null);\n  const [viewportElem, setViewportElem] = useState(null);\n\n  const { trackedSeries } = trackedMeasurements.context;\n\n  const { SeriesInstanceUID } = displaySet;\n\n  const updateIsTracked = useCallback(() => {\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n    if (viewport instanceof BaseVolumeViewport) {\n      // A current image id will only exist for volume viewports that can have measurements tracked.\n      // Typically these are those volume viewports for the series of acquisition.\n      const currentImageId = viewport?.getCurrentImageId();\n\n      if (!currentImageId) {\n        if (isTracked) {\n          setIsTracked(false);\n        }\n        return;\n      }\n    }\n\n    if (trackedSeries.includes(SeriesInstanceUID) !== isTracked) {\n      setIsTracked(!isTracked);\n    }\n  }, [isTracked, trackedMeasurements, viewportId, SeriesInstanceUID]);\n\n  const onElementEnabled = useCallback(\n    evt => {\n      if (evt.detail.element !== viewportElem) {\n        // The VOLUME_VIEWPORT_NEW_VOLUME event allows updateIsTracked to reliably fetch the image id for a volume viewport.\n        evt.detail.element?.addEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          updateIsTracked\n        );\n        setViewportElem(evt.detail.element);\n      }\n    },\n    [updateIsTracked, viewportElem]\n  );\n\n  const onElementDisabled = useCallback(() => {\n    viewportElem?.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, updateIsTracked);\n  }, [updateIsTracked, viewportElem]);\n\n  useEffect(updateIsTracked, [updateIsTracked]);\n\n  useEffect(() => {\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n      props => {\n        if (props.viewportId !== viewportId) {\n          return;\n        }\n\n        updateIsTracked();\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [updateIsTracked, viewportId]);\n\n  useEffect(() => {\n    if (isTracked) {\n      annotation.config.style.setViewportToolStyles(viewportId, {\n        ReferenceLines: {\n          lineDash: '4,4',\n        },\n        global: {\n          lineDash: '',\n        },\n      });\n\n      cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\n\n      return;\n    }\n\n    annotation.config.style.setViewportToolStyles(viewportId, {\n      global: {\n        lineDash: '4,4',\n      },\n    });\n\n    cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\n\n    return () => {\n      annotation.config.style.setViewportToolStyles(viewportId, {});\n    };\n  }, [isTracked]);\n\n  /**\n   * The effect for listening to measurement service measurement added events\n   * and in turn firing an event to update the measurement tracking state machine.\n   * The TrackedCornerstoneViewport is the best place for this because when\n   * a measurement is added, at least one TrackedCornerstoneViewport will be in\n   * the DOM and thus can react to the events fired.\n   */\n  useEffect(() => {\n    const added = measurementService.EVENTS.MEASUREMENT_ADDED;\n    const addedRaw = measurementService.EVENTS.RAW_MEASUREMENT_ADDED;\n    const subscriptions = [];\n\n    [added, addedRaw].forEach(evt => {\n      subscriptions.push(\n        measurementService.subscribe(evt, ({ source, measurement }) => {\n          const { activeViewportId } = viewportGridService.getState();\n\n          // Each TrackedCornerstoneViewport receives the MeasurementService's events.\n          // Only send the tracked measurements event for the active viewport to avoid\n          // sending it more than once.\n          if (viewportId === activeViewportId) {\n            const {\n              referenceStudyUID: StudyInstanceUID,\n              referenceSeriesUID: SeriesInstanceUID,\n              uid: measurementId,\n              toolName,\n            } = measurement;\n\n            sendTrackedMeasurementsEvent('SET_DIRTY', { SeriesInstanceUID });\n            sendTrackedMeasurementsEvent('TRACK_SERIES', {\n              viewportId,\n              StudyInstanceUID,\n              SeriesInstanceUID,\n              measurementId,\n              toolName,\n            });\n          }\n        }).unsubscribe\n      );\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, [measurementService, sendTrackedMeasurementsEvent, viewportId, viewportGridService]);\n\n  const switchMeasurement = useCallback(\n    direction => {\n      const newTrackedMeasurementUID = _getNextMeasurementUID(\n        direction,\n        servicesManager,\n        trackedMeasurementUID,\n        trackedMeasurements\n      );\n\n      if (!newTrackedMeasurementUID) {\n        return;\n      }\n\n      setTrackedMeasurementUID(newTrackedMeasurementUID);\n\n      measurementService.jumpToMeasurement(viewportId, newTrackedMeasurementUID);\n    },\n    [measurementService, servicesManager, trackedMeasurementUID, trackedMeasurements, viewportId]\n  );\n\n  const getCornerstoneViewport = () => {\n    return (\n      <OHIFCornerstoneViewport\n        {...props}\n        onElementEnabled={evt => {\n          props.onElementEnabled?.(evt);\n          onElementEnabled(evt);\n        }}\n        onElementDisabled={onElementDisabled}\n      />\n    );\n  };\n\n  return (\n    <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n      {getCornerstoneViewport()}\n    </div>\n  );\n}\n\nTrackedCornerstoneViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object.isRequired).isRequired,\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n};\n\nfunction _getNextMeasurementUID(\n  direction,\n  servicesManager: AppTypes.ServicesManager,\n  trackedMeasurementId,\n  trackedMeasurements\n) {\n  const { measurementService, viewportGridService } = servicesManager.services;\n  const measurements = measurementService.getMeasurements();\n\n  const { activeViewportId, viewports } = viewportGridService.getState();\n  const { displaySetInstanceUIDs: activeViewportDisplaySetInstanceUIDs } =\n    viewports.get(activeViewportId);\n\n  const { trackedSeries } = trackedMeasurements.context;\n\n  // Get the potentially trackable measurements for the series of the\n  // active viewport.\n  // The measurements to jump between are the same\n  // regardless if this series is tracked or not.\n\n  const filteredMeasurements = measurements.filter(\n    m =>\n      trackedSeries.includes(m.referenceSeriesUID) &&\n      activeViewportDisplaySetInstanceUIDs.includes(m.displaySetInstanceUID)\n  );\n\n  if (!filteredMeasurements.length) {\n    // No measurements on this series.\n    return;\n  }\n\n  const measurementCount = filteredMeasurements.length;\n\n  const uids = filteredMeasurements.map(fm => fm.uid);\n  let measurementIndex = uids.findIndex(uid => uid === trackedMeasurementId);\n\n  if (measurementIndex === -1) {\n    // Not tracking a measurement, or previous measurement now deleted, revert to 0.\n    measurementIndex = 0;\n  } else {\n    measurementIndex += direction;\n    if (measurementIndex < 0) {\n      measurementIndex = measurementCount - 1;\n    } else if (measurementIndex === measurementCount) {\n      measurementIndex = 0;\n    }\n  }\n\n  const newTrackedMeasurementId = uids[measurementIndex];\n\n  return newTrackedMeasurementId;\n}\n\nconst _getArrowsComponent = (isTracked, switchMeasurement, isActiveViewport) => {\n  if (!isTracked) {\n    return null;\n  }\n\n  return (\n    <ViewportActionArrows\n      onArrowsClick={direction => switchMeasurement(direction)}\n      className={isActiveViewport ? 'visible' : 'invisible group-hover/pane:visible'}\n    />\n  );\n};\n\nexport default TrackedCornerstoneViewport;\n"],"names":[],"sourceRoot":""}