{"version":3,"file":"extensions_cornerstone-dicom-sr_src_components_OHIFCornerstoneSRViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAIA;AAEA;AAEA;AAAA;AAIA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAOA;AAEA;AAEA;AAAA;AACA;AAAA;AAIA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAEA;AAKA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAMA;AAAA;AAxNA;AAsBA;AAAA;AAoMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA","sources":["file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRContainer.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRContentItem.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRMeasurementViewport.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRTextViewport.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRViewport.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/cornerstone-dicom-sr/src/utils/formatContentItem.ts"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport { OHIFCornerstoneSRContentItem } from './OHIFCornerstoneSRContentItem';\n\nexport function OHIFCornerstoneSRContainer(props) {\n  const { container, nodeIndexesTree = [0], containerNumberedTree = [1] } = props;\n  const { ContinuityOfContent, ConceptNameCodeSequence } = container;\n  const { CodeMeaning } = ConceptNameCodeSequence ?? {};\n  let childContainerIndex = 1;\n  const contentItems = container.ContentSequence?.map((contentItem, i) => {\n    const { ValueType } = contentItem;\n    const childNodeLevel = [...nodeIndexesTree, i];\n    const key = childNodeLevel.join('.');\n\n    let Component;\n    let componentProps;\n\n    if (ValueType === 'CONTAINER') {\n      const childContainerNumberedTree = [...containerNumberedTree, childContainerIndex++];\n\n      Component = OHIFCornerstoneSRContainer;\n      componentProps = {\n        container: contentItem,\n        nodeIndexesTree: childNodeLevel,\n        containerNumberedTree: childContainerNumberedTree,\n      };\n    } else {\n      Component = OHIFCornerstoneSRContentItem;\n      componentProps = {\n        contentItem,\n        nodeIndexesTree: childNodeLevel,\n        continuityOfContent: ContinuityOfContent,\n      };\n    }\n\n    return (\n      <Component\n        key={key}\n        {...componentProps}\n      />\n    );\n  });\n\n  return (\n    <div>\n      <div className=\"font-bold\">\n        {containerNumberedTree.join('.')}.&nbsp;\n        {CodeMeaning}\n      </div>\n      <div className=\"ml-4 mb-2\">{contentItems}</div>\n    </div>\n  );\n}\n\nOHIFCornerstoneSRContainer.propTypes = {\n  /**\n   * A tree node that may contain another container or one or more content items\n   * (text, code, uidref, pname, etc.)\n   */\n  container: PropTypes.object,\n  /**\n   * A 0-based index list\n   */\n  nodeIndexesTree: PropTypes.arrayOf(PropTypes.number),\n  /**\n   * A 1-based index list that represents a container in a multi-level numbered\n   * list (tree).\n   *\n   * Example:\n   *  1. History\n   *    1.1. Chief Complaint\n   *    1.2. Present Illness\n   *    1.3. Past History\n   *    1.4. Family History\n   *  2. Findings\n   * */\n  containerNumberedTree: PropTypes.arrayOf(PropTypes.number),\n};\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { CodeNameCodeSequenceValues } from '../enums';\nimport formatContentItemValue from '../utils/formatContentItem';\n\nconst EMPTY_TAG_VALUE = '[empty]';\n\nfunction OHIFCornerstoneSRContentItem(props) {\n  const { contentItem, nodeIndexesTree, continuityOfContent } = props;\n  const { ConceptNameCodeSequence } = contentItem;\n  const { CodeValue, CodeMeaning } = ConceptNameCodeSequence;\n  const isChildFirstNode = nodeIndexesTree[nodeIndexesTree.length - 1] === 0;\n  const formattedValue = formatContentItemValue(contentItem) ?? EMPTY_TAG_VALUE;\n  const startWithAlphaNumCharRegEx = /^[a-zA-Z0-9]/;\n  const isContinuous = continuityOfContent === 'CONTINUOUS';\n  const isFinding = CodeValue === CodeNameCodeSequenceValues.Finding;\n  const addExtraSpace =\n    isContinuous && !isChildFirstNode && startWithAlphaNumCharRegEx.test(formattedValue?.[0]);\n\n  // Collapse sequences of white space preserving newline characters\n  let className = 'whitespace-pre-line';\n\n  if (CodeValue === CodeNameCodeSequenceValues.Finding) {\n    // Preserve spaces because it is common to see tabular text in a\n    // \"Findings\" ConceptNameCodeSequence\n    className = 'whitespace-pre-wrap';\n  }\n\n  if (isContinuous) {\n    return (\n      <>\n        <span\n          className={className}\n          title={CodeMeaning}\n        >\n          {addExtraSpace ? ' ' : ''}\n          {formattedValue}\n        </span>\n      </>\n    );\n  }\n\n  return (\n    <>\n      <div className=\"mb-2\">\n        <span className=\"font-bold\">{CodeMeaning}: </span>\n        {isFinding ? (\n          <pre>{formattedValue}</pre>\n        ) : (\n          <span className={className}>{formattedValue}</span>\n        )}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneSRContentItem.propTypes = {\n  contentItem: PropTypes.object,\n  nodeIndexesTree: PropTypes.arrayOf(PropTypes.number),\n  continuityOfContent: PropTypes.string,\n};\n\nexport { OHIFCornerstoneSRContentItem };\n","import PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useState } from 'react';\nimport { setTrackingUniqueIdentifiersForElement } from '../tools/modules/dicomSRModule';\n\nimport createReferencedImageDisplaySet from '../utils/createReferencedImageDisplaySet';\nimport { usePositionPresentationStore, OHIFCornerstoneViewport } from '@ohif/extension-cornerstone';\nimport { useViewportGrid } from '@ohif/ui-next';\nimport { useSystem } from '@ohif/core/src/contextProviders/SystemProvider';\n\nconst SR_TOOLGROUP_BASE_NAME = 'SRToolGroup';\n\nfunction OHIFCornerstoneSRMeasurementViewport(props) {\n  const { servicesManager } = useSystem();\n  const { children, dataSource, displaySets, viewportOptions } = props as {\n    children: React.ReactNode;\n    dataSource: unknown;\n    displaySets: AppTypes.DisplaySet[];\n    viewportOptions: AppTypes.ViewportOptions;\n  };\n\n  const { displaySetService } = servicesManager.services;\n\n  const viewportId = viewportOptions.viewportId;\n\n  // SR viewport will always have a single display set\n  if (displaySets.length > 1) {\n    throw new Error('SR viewport should only have a single display set');\n  }\n\n  const srDisplaySet = displaySets[0];\n\n  const { setPositionPresentation } = usePositionPresentationStore();\n\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n  const [measurementSelected, setMeasurementSelected] = useState(0);\n  const [activeImageDisplaySetData, setActiveImageDisplaySetData] = useState(null);\n  const [referencedDisplaySetMetadata, setReferencedDisplaySetMetadata] = useState(null);\n  const [element, setElement] = useState(null);\n  const { viewports, activeViewportId } = viewportGrid;\n\n  const setTrackingIdentifiers = useCallback(\n    measurementSelected => {\n      const { measurements } = srDisplaySet;\n\n      setTrackingUniqueIdentifiersForElement(\n        element,\n        measurements.map(measurement => measurement.TrackingUniqueIdentifier),\n        measurementSelected\n      );\n    },\n    [element, measurementSelected, srDisplaySet]\n  );\n\n  /**\n   * OnElementEnabled callback which is called after the cornerstoneExtension\n   * has enabled the element. Note: we delegate all the image rendering to\n   * cornerstoneExtension, so we don't need to do anything here regarding\n   * the image rendering, element enabling etc.\n   */\n  const onElementEnabled = evt => {\n    setElement(evt.detail.element);\n  };\n\n  const updateViewport = useCallback(\n    newMeasurementSelected => {\n      const { StudyInstanceUID, displaySetInstanceUID, sopClassUids } = srDisplaySet;\n\n      if (!StudyInstanceUID || !displaySetInstanceUID) {\n        return;\n      }\n\n      if (sopClassUids && sopClassUids.length > 1) {\n        // Todo: what happens if there are multiple SOP Classes? Why we are\n        // not throwing an error?\n        console.warn('More than one SOPClassUID in the same series is not yet supported.');\n      }\n\n      _getViewportReferencedDisplaySetData(\n        srDisplaySet,\n        newMeasurementSelected,\n        displaySetService\n      ).then(({ referencedDisplaySet, referencedDisplaySetMetadata }) => {\n        if (!referencedDisplaySet || !referencedDisplaySetMetadata) {\n          return;\n        }\n\n        setMeasurementSelected(newMeasurementSelected);\n\n        setActiveImageDisplaySetData(referencedDisplaySet);\n        setReferencedDisplaySetMetadata(referencedDisplaySetMetadata);\n\n        const { presentationIds } = viewportOptions;\n        const measurement = srDisplaySet.measurements[newMeasurementSelected];\n        setPositionPresentation(presentationIds.positionPresentationId, {\n          viewReference: {\n            referencedImageId: measurement.imageId,\n          },\n        });\n      });\n    },\n    [dataSource, srDisplaySet, activeImageDisplaySetData, viewportId]\n  );\n\n  const getCornerstoneViewport = useCallback(() => {\n    if (!activeImageDisplaySetData) {\n      return null;\n    }\n\n    const { measurements } = srDisplaySet;\n    const measurement = measurements[measurementSelected];\n\n    if (!measurement) {\n      return null;\n    }\n\n    return (\n      <OHIFCornerstoneViewport\n        {...props}\n        // should be passed second since we don't want SR displaySet to\n        // override the activeImageDisplaySetData\n        displaySets={[activeImageDisplaySetData]}\n        // It is possible that there is a hanging protocol applying viewportOptions\n        // for the SR, so inherit the viewport options\n        // TODO: Ensure the viewport options are set correctly with respect to\n        // stack etc, in the incoming viewport options.\n        viewportOptions={{\n          ...viewportOptions,\n          toolGroupId: `${SR_TOOLGROUP_BASE_NAME}`,\n          // viewportType should not be required, as the stack type should be\n          // required already in order to view SR, but sometimes segmentation\n          // views set the viewport type without fixing the allowed display\n          viewportType: 'stack',\n          // The positionIds for the viewport aren't meaningful for the child display sets\n          positionIds: null,\n        }}\n        onElementEnabled={evt => {\n          props.onElementEnabled?.(evt);\n          onElementEnabled(evt);\n        }}\n        isJumpToMeasurementDisabled={true}\n      />\n    );\n  }, [activeImageDisplaySetData, viewportId, measurementSelected]);\n\n  /**\n   Cleanup the SR viewport when the viewport is destroyed\n   */\n  useEffect(() => {\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\n      ({ displaySetInstanceUIDs }) => {\n        const activeViewport = viewports.get(activeViewportId);\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\n          viewportGridService.setDisplaySetsForViewport({\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [],\n          });\n        }\n      }\n    );\n\n    return () => {\n      onDisplaySetsRemovedSubscription.unsubscribe();\n    };\n  }, []);\n\n  /**\n   * Loading the measurements from the SR viewport, which goes through the\n   * isHydratable check, the outcome for the isHydrated state here is always FALSE\n   * since we don't do the hydration here. Todo: can't we just set it as false? why\n   * we are changing the state here? isHydrated is always false at this stage, and\n   * if it is hydrated we don't even use the SR viewport.\n   */\n  useEffect(() => {\n    const loadSR = async () => {\n      if (!srDisplaySet.isLoaded) {\n        await srDisplaySet.load();\n      }\n      updateViewport(measurementSelected);\n    };\n    loadSR();\n  }, [srDisplaySet]);\n\n  /**\n   * Hook to update the tracking identifiers when the selected measurement changes or\n   * the element changes\n   */\n  useEffect(() => {\n    const updateSR = async () => {\n      if (!srDisplaySet.isLoaded) {\n        await srDisplaySet.load();\n      }\n      if (!element || !srDisplaySet.isLoaded) {\n        return;\n      }\n      setTrackingIdentifiers(measurementSelected);\n    };\n    updateSR();\n  }, [measurementSelected, element, setTrackingIdentifiers, srDisplaySet]);\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  let childrenWithProps = null;\n\n  if (!activeImageDisplaySetData || !referencedDisplaySetMetadata) {\n    return null;\n  }\n\n  if (children && children.length) {\n    childrenWithProps = children.map((child, index) => {\n      return (\n        child &&\n        React.cloneElement(child, {\n          viewportId,\n          key: index,\n        })\n      );\n    });\n  }\n\n  return (\n    <>\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {getCornerstoneViewport()}\n        {childrenWithProps}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneSRMeasurementViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  viewportLabel: PropTypes.string,\n  viewportOptions: PropTypes.object,\n};\n\nasync function _getViewportReferencedDisplaySetData(\n  displaySet,\n  measurementSelected,\n  displaySetService\n) {\n  const { measurements } = displaySet;\n  const measurement = measurements[measurementSelected];\n\n  const { displaySetInstanceUID } = measurement;\n  if (!displaySet.keyImageDisplaySet) {\n    // Create a new display set, and preserve a reference to it here,\n    // so that it can be re-displayed and shown inside the SR viewport.\n    // This is only for ease of redisplay - the display set is stored in the\n    // usual manner in the display set service.\n    displaySet.keyImageDisplaySet = createReferencedImageDisplaySet(displaySetService, displaySet);\n  }\n\n  if (!displaySetInstanceUID) {\n    return { referencedDisplaySetMetadata: null, referencedDisplaySet: null };\n  }\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  const image0 = referencedDisplaySet.images[0];\n  const referencedDisplaySetMetadata = {\n    PatientID: image0.PatientID,\n    PatientName: image0.PatientName,\n    PatientSex: image0.PatientSex,\n    PatientAge: image0.PatientAge,\n    SliceThickness: image0.SliceThickness,\n    StudyDate: image0.StudyDate,\n    SeriesDescription: image0.SeriesDescription,\n    SeriesInstanceUID: image0.SeriesInstanceUID,\n    SeriesNumber: image0.SeriesNumber,\n    ManufacturerModelName: image0.ManufacturerModelName,\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\n  };\n\n  return { referencedDisplaySetMetadata, referencedDisplaySet };\n}\n\nexport default OHIFCornerstoneSRMeasurementViewport;\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { ExtensionManager } from '@ohif/core';\nimport { OHIFCornerstoneSRContainer } from './OHIFCornerstoneSRContainer';\n\nfunction OHIFCornerstoneSRTextViewport(props: withAppTypes) {\n  const { displaySets } = props;\n  const displaySet = displaySets[0];\n  const instance = displaySet.instances[0];\n\n  return (\n    <div className=\"relative flex h-full w-full flex-col overflow-auto p-4 text-white\">\n      <div>\n        {/* The root level is always a container */}\n        <OHIFCornerstoneSRContainer container={instance} />\n      </div>\n    </div>\n  );\n}\n\nOHIFCornerstoneSRTextViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  viewportLabel: PropTypes.string,\n  viewportOptions: PropTypes.object,\n  servicesManager: PropTypes.object.isRequired,\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\n};\n\nexport default OHIFCornerstoneSRTextViewport;\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { ExtensionManager } from '@ohif/core';\n\nimport OHIFCornerstoneSRMeasurementViewport from './OHIFCornerstoneSRMeasurementViewport';\nimport OHIFCornerstoneSRTextViewport from './OHIFCornerstoneSRTextViewport';\n\nfunction OHIFCornerstoneSRViewport(props: withAppTypes) {\n  const { displaySets } = props;\n  const { isImagingMeasurementReport } = displaySets[0];\n\n  if (isImagingMeasurementReport) {\n    return <OHIFCornerstoneSRMeasurementViewport {...props}></OHIFCornerstoneSRMeasurementViewport>;\n  }\n\n  return <OHIFCornerstoneSRTextViewport {...props}></OHIFCornerstoneSRTextViewport>;\n}\n\nOHIFCornerstoneSRViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  viewportLabel: PropTypes.string,\n  viewportOptions: PropTypes.object,\n  servicesManager: PropTypes.object.isRequired,\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\n};\n\nexport default OHIFCornerstoneSRViewport;\n","import { utils } from '@ohif/core';\n\n/**\n * Formatters used to format each of the content items (SR \"nodes\") which can be\n * text, code, UID ref, number, person name, date, time and date time. Each\n * formatter must be a function with the following signature:\n *\n *    [VALUE_TYPE]: (contentItem) => string\n *\n */\nconst contentItemFormatters = {\n  TEXT: contentItem => contentItem.TextValue,\n  CODE: contentItem => contentItem.ConceptCodeSequence?.[0]?.CodeMeaning,\n  UIDREF: contentItem => contentItem.UID,\n  NUM: contentItem => {\n    const measuredValue = contentItem.MeasuredValueSequence?.[0];\n\n    if (!measuredValue) {\n      return;\n    }\n\n    const { NumericValue, MeasurementUnitsCodeSequence } = measuredValue;\n    const { CodeValue } = MeasurementUnitsCodeSequence;\n\n    return `${NumericValue} ${CodeValue}`;\n  },\n  PNAME: contentItem => {\n    const personName = contentItem.PersonName?.[0];\n    return personName ? utils.formatPN(personName) : undefined;\n  },\n  DATE: contentItem => {\n    const { Date } = contentItem;\n    return Date ? utils.formatDate(Date) : undefined;\n  },\n  TIME: contentItem => {\n    const { Time } = contentItem;\n    return Time ? utils.formatTime(Time) : undefined;\n  },\n  DATETIME: contentItem => {\n    const { DateTime } = contentItem;\n\n    if (typeof DateTime !== 'string') {\n      return;\n    }\n\n    // 14 characters because it should be something like 20180614113714\n    if (DateTime.length < 14) {\n      return DateTime;\n    }\n\n    const dicomDate = DateTime.substring(0, 8);\n    const dicomTime = DateTime.substring(8, 14);\n    const formattedDate = utils.formatDate(dicomDate);\n    const formattedTime = utils.formatTime(dicomTime);\n\n    return `${formattedDate} ${formattedTime}`;\n  },\n};\n\nfunction formatContentItemValue(contentItem) {\n  const { ValueType } = contentItem;\n  const fnFormat = contentItemFormatters[ValueType];\n\n  return fnFormat ? fnFormat(contentItem) : `[${ValueType} is not supported]`;\n}\n\nexport { formatContentItemValue as default, formatContentItemValue };\n"],"names":[],"sourceRoot":""}