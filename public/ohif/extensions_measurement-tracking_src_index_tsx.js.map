{"version":3,"file":"extensions_measurement-tracking_src_index_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAIA;AAMA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AAIA;AACA;AACA;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAKA;AAAA;AA9VA;AAiPA;AAAA;AA+GA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClYA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAMA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAIA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/hBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChFA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxHA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAIA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AASA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AAMA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAOA;AAAA;AA/FA;AAKA;AAAA;AA4FA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAMA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AA/HA;AASA;AAAA;AAwHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AAKA;AAEA;AACA;AACA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAzBA;AACA;AAAA;AAiCA;AACA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AAIA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAQA;AAAA;AAxBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAtJA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAiJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA","sources":["file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/TrackedMeasurementsContext.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/hydrateStructuredReport.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/index.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/measurementTrackingMachine.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptBeginTracking.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptHasDirtyAnnotations.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptHydrateStructuredReport.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptTrackNewSeries.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptTrackNewStudy.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptWrapperFunctions.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/contexts/index.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/customizations/measurementTrackingPrompts.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/customizations/studyBrowserCustomization.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/getContextModule.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/getCustomizationModule.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/getPanelModule.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/getViewportModule.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/id.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/index.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/panels/PanelMeasurementTableTracking.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/PanelStudyBrowserTracking.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/getImageSrcFromImageId.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/index.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/untrackSeriesModal.tsx","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/panels/index.js","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/services/TrackedMeasurementsService/TrackedMeasurementsService.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/services/TrackedMeasurementsService/index.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/services/index.ts","file:////home/balasakthi/Downloads/Viewers-master/extensions/measurement-tracking/src/types/index.ts"],"sourcesContent":["import React, { useContext, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { Machine } from 'xstate';\nimport { useMachine } from '@xstate/react';\nimport { useViewportGrid } from '@ohif/ui-next';\nimport { machineConfiguration, defaultOptions, RESPONSE } from './measurementTrackingMachine';\nimport { measurementTrackingMode } from './promptBeginTracking';\nimport hydrateStructuredReport from './hydrateStructuredReport';\nimport { useAppConfig } from '@state';\nimport {\n  promptBeginTrackingWrapper,\n  promptHydrateStructuredReportWrapper,\n  promptTrackNewSeriesWrapper,\n  promptTrackNewStudyWrapper,\n  promptLabelAnnotationWrapper,\n  promptSaveReportWrapper,\n  promptHasDirtyAnnotationsWrapper,\n} from './promptWrapperFunctions';\n\nconst TrackedMeasurementsContext = React.createContext();\nTrackedMeasurementsContext.displayName = 'TrackedMeasurementsContext';\nconst useTrackedMeasurements = () => useContext(TrackedMeasurementsContext);\n\nconst SR_SOPCLASSHANDLERID = '@ohif/extension-cornerstone-dicom-sr.sopClassHandlerModule.dicom-sr';\n\n/**\n *\n * @param {*} param0\n */\nfunction TrackedMeasurementsContextProvider(\n  { servicesManager, commandsManager, extensionManager }: withAppTypes, // Bound by consumer\n  { children } // Component props\n) {\n  const [appConfig] = useAppConfig();\n\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n  const { activeViewportId, viewports } = viewportGrid;\n  const {\n    measurementService,\n    displaySetService,\n    customizationService,\n    trackedMeasurementsService,\n  } = servicesManager.services as AppTypes.Services;\n\n  const machineOptions = Object.assign({}, defaultOptions);\n  machineOptions.actions = Object.assign({}, machineOptions.actions, {\n    jumpToFirstMeasurementInActiveViewport: (ctx, evt) => {\n      const { trackedStudy, trackedSeries } = ctx;\n      const { viewportId: activeViewportId } = evt.data;\n      const measurements = measurementService.getMeasurements();\n      const trackedMeasurements = measurements.filter(\n        m => trackedStudy === m.referenceStudyUID && trackedSeries.includes(m.referenceSeriesUID)\n      );\n\n      console.log(\n        'jumping to measurement reset viewport',\n        activeViewportId,\n        trackedMeasurements[0]\n      );\n\n      const referencedDisplaySetUID = trackedMeasurements[0].displaySetInstanceUID;\n      const referencedDisplaySet = displaySetService.getDisplaySetByUID(referencedDisplaySetUID);\n\n      const referencedImages = referencedDisplaySet.images;\n      const isVolumeIdReferenced = referencedImages[0].imageId.startsWith('volumeId');\n\n      const measurementData = trackedMeasurements[0].data;\n\n      let imageIndex = 0;\n      if (!isVolumeIdReferenced && measurementData) {\n        // if it is imageId referenced find the index of the imageId, we don't have\n        // support for volumeId referenced images yet\n        imageIndex = referencedImages.findIndex(image => {\n          const imageIdToUse = Object.keys(measurementData)[0].substring(8);\n          return image.imageId === imageIdToUse;\n        });\n\n        if (imageIndex === -1) {\n          console.warn('Could not find image index for tracked measurement, using 0');\n          imageIndex = 0;\n        }\n      }\n\n      viewportGridService.setDisplaySetsForViewport({\n        viewportId: activeViewportId,\n        displaySetInstanceUIDs: [referencedDisplaySetUID],\n        viewportOptions: {\n          initialImageOptions: {\n            index: imageIndex,\n          },\n        },\n      });\n    },\n\n    jumpToSameImageInActiveViewport: (ctx, evt) => {\n      const { trackedStudy, trackedSeries } = ctx;\n      const { viewportId: activeViewportId } = evt.data;\n      const measurements = measurementService.getMeasurements();\n      const trackedMeasurements = measurements.filter(\n        m => trackedStudy === m.referenceStudyUID && trackedSeries.includes(m.referenceSeriesUID)\n      );\n\n      // Jump to the last tracked measurement - most recent\n      if (!trackedMeasurements?.length) {\n        console.warn(\n          \"Didn't find any tracked measurements\",\n          measurements,\n          trackedStudy,\n          trackedSeries\n        );\n        return;\n      }\n      const trackedMeasurement = trackedMeasurements[trackedMeasurements.length - 1];\n      const referencedDisplaySetUID = trackedMeasurement.displaySetInstanceUID;\n\n      // update the previously stored positionPresentation with the new viewportId\n      // presentation so that when we put the referencedDisplaySet back in the viewport\n      // it will be in the correct position zoom and pan\n      commandsManager.runCommand('updateStoredPositionPresentation', {\n        viewportId: activeViewportId,\n        displaySetInstanceUIDs: [referencedDisplaySetUID],\n        referencedImageId: trackedMeasurement.referencedImageId,\n      });\n\n      viewportGridService.setDisplaySetsForViewport({\n        viewportId: activeViewportId,\n        displaySetInstanceUIDs: [referencedDisplaySetUID],\n      });\n    },\n    showStructuredReportDisplaySetInActiveViewport: (ctx, evt) => {\n      if (evt.data.createdDisplaySetInstanceUIDs.length > 0) {\n        const StructuredReportDisplaySetInstanceUID = evt.data.createdDisplaySetInstanceUIDs[0];\n\n        viewportGridService.setDisplaySetsForViewport({\n          viewportId: evt.data.viewportId,\n          displaySetInstanceUIDs: [StructuredReportDisplaySetInstanceUID],\n        });\n      }\n    },\n    discardPreviouslyTrackedMeasurements: (ctx, evt) => {\n      const measurements = measurementService.getMeasurements();\n      const filteredMeasurements = measurements.filter(ms =>\n        ctx.prevTrackedSeries.includes(ms.referenceSeriesUID)\n      );\n      const measurementIds = filteredMeasurements.map(fm => fm.id);\n\n      for (let i = 0; i < measurementIds.length; i++) {\n        measurementService.remove(measurementIds[i]);\n      }\n    },\n    clearAllMeasurements: (ctx, evt) => {\n      measurementService.clearMeasurements();\n      measurementService.setIsMeasurementDeletedIndividually(false);\n    },\n    clearDisplaySetHydratedState: (ctx, evt) => {\n      const { displaySetInstanceUID } = evt.data ?? evt;\n\n      const displaysets = displaySetService.getActiveDisplaySets();\n      displaysets?.forEach(displayset => {\n        if (\n          displayset.Modality === 'SR' &&\n          displayset.displaySetInstanceUID !== displaySetInstanceUID &&\n          displayset.isHydrated\n        ) {\n          displayset.isHydrated = false;\n          displayset.isLoaded = false;\n        }\n      });\n    },\n    updatedViewports: (ctx, evt) => {\n      const { hangingProtocolService } = servicesManager.services;\n      const { displaySetInstanceUID, viewportId } = evt.data ?? evt;\n\n      const updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n        viewportId,\n        displaySetInstanceUID\n      );\n\n      viewportGridService.setDisplaySetsForViewports(updatedViewports);\n    },\n  });\n  machineOptions.services = Object.assign({}, machineOptions.services, {\n    promptBeginTracking: promptBeginTrackingWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptTrackNewSeries: promptTrackNewSeriesWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptTrackNewStudy: promptTrackNewStudyWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptSaveReport: promptSaveReportWrapper.bind(null, {\n      servicesManager,\n      commandsManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptHydrateStructuredReport: promptHydrateStructuredReportWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n      appConfig,\n    }),\n    promptHasDirtyAnnotations: promptHasDirtyAnnotationsWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n      appConfig,\n    }),\n    hydrateStructuredReport: hydrateStructuredReport.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n      appConfig,\n    }),\n    promptLabelAnnotation: promptLabelAnnotationWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n    }),\n  });\n  machineOptions.guards = Object.assign({}, machineOptions.guards, {\n    isLabelOnMeasure: (ctx, evt, condMeta) => {\n      const labelConfig = customizationService.getCustomization('measurementLabels');\n      return labelConfig?.labelOnMeasure;\n    },\n    isLabelOnMeasureAndShouldKillMachine: (ctx, evt, condMeta) => {\n      const labelConfig = customizationService.getCustomization('measurementLabels');\n      return evt.data && evt.data.userResponse === RESPONSE.NO_NEVER && labelConfig?.labelOnMeasure;\n    },\n    isSimplifiedConfig: (ctx, evt, condMeta) => {\n      return appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED;\n    },\n    simplifiedAndLoadSR: (ctx, evt, condMeta) => {\n      return (\n        appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED &&\n        evt.data.isBackupSave === false\n      );\n    },\n    hasDirtyAndSimplified: (ctx, evt, condMeta) => {\n      const measurements = measurementService.getMeasurements();\n      const hasDirtyMeasurements =\n        measurements.some(measurement => measurement.isDirty) ||\n        (measurements.length && measurementService.getIsMeasurementDeletedIndividually());\n      return (\n        appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED &&\n        hasDirtyMeasurements\n      );\n    },\n  });\n\n  // TODO: IMPROVE\n  // - Add measurement_updated to cornerstone; debounced? (ext side, or consumption?)\n  // - Friendlier transition/api in front of measurementTracking machine?\n  // - Blocked: viewport overlay shouldn't clip when resized\n  // TODO: PRIORITY\n  // - Fix \"ellipses\" series description dynamic truncate length\n  // - Fix viewport border resize\n  // - created/destroyed hooks for extensions (cornerstone measurement subscriptions in it's `init`)\n\n  const measurementTrackingMachine = useMemo(() => {\n    return Machine(machineConfiguration, machineOptions);\n  }, []); // Empty dependency array ensures this is only created once\n\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useMachine(\n    measurementTrackingMachine\n  );\n\n  // Update TrackedMeasurementsService when trackedSeries changes in context\n  useEffect(() => {\n    if (trackedMeasurements?.context?.trackedSeries && trackedMeasurementsService) {\n      trackedMeasurementsService.updateTrackedSeries(trackedMeasurements.context.trackedSeries);\n    }\n  }, [trackedMeasurements?.context?.trackedSeries, trackedMeasurementsService]);\n\n  useEffect(() => {\n    // Update the state machine with the active viewport ID\n    sendTrackedMeasurementsEvent('UPDATE_ACTIVE_VIEWPORT_ID', {\n      activeViewportId,\n    });\n  }, [activeViewportId, sendTrackedMeasurementsEvent]);\n\n  // ~~ Listen for changes to ViewportGrid for potential SRs hung in panes when idle\n  useEffect(() => {\n    const triggerPromptHydrateFlow = async () => {\n      if (viewports.size > 0) {\n        const activeViewport = viewports.get(activeViewportId);\n\n        if (!activeViewport || !activeViewport?.displaySetInstanceUIDs?.length) {\n          return;\n        }\n\n        // Todo: Getting the first displaySetInstanceUID is wrong, but we don't have\n        // tracking fusion viewports yet. This should change when we do.\n        const { displaySetService } = servicesManager.services;\n        const displaySet = displaySetService.getDisplaySetByUID(\n          activeViewport.displaySetInstanceUIDs[0]\n        );\n\n        if (!displaySet) {\n          return;\n        }\n\n        // If this is an SR produced by our SR SOPClassHandler,\n        // and it hasn't been loaded yet, do that now so we\n        // can check if it can be rehydrated or not.\n        //\n        // Note: This happens:\n        // - If the viewport is not currently an OHIFCornerstoneSRViewport\n        // - If the displaySet has never been hung\n        //\n        // Otherwise, the displaySet will be loaded by the useEffect handler\n        // listening to displaySet changes inside OHIFCornerstoneSRViewport.\n        // The issue here is that this handler in TrackedMeasurementsContext\n        // ends up occurring before the Viewport is created, so the displaySet\n        // is not loaded yet, and isRehydratable is undefined unless we call load().\n        if (\n          displaySet.SOPClassHandlerId === SR_SOPCLASSHANDLERID &&\n          !displaySet.isLoaded &&\n          displaySet.load\n        ) {\n          await displaySet.load();\n        }\n\n        // Magic string\n        // load function added by our sopClassHandler module\n        if (\n          displaySet.SOPClassHandlerId === SR_SOPCLASSHANDLERID &&\n          displaySet.isRehydratable === true &&\n          !displaySet.isHydrated\n        ) {\n          const params = {\n            displaySetInstanceUID: displaySet.displaySetInstanceUID,\n            SeriesInstanceUID: displaySet.SeriesInstanceUID,\n            viewportId: activeViewportId,\n          };\n\n          // Check if we should bypass the confirmation prompt\n          const disableConfirmationPrompts = appConfig?.disableConfirmationPrompts;\n\n          if (disableConfirmationPrompts) {\n            sendTrackedMeasurementsEvent('HYDRATE_SR', params);\n          } else {\n            sendTrackedMeasurementsEvent('PROMPT_HYDRATE_SR', params);\n          }\n        }\n      }\n    };\n    triggerPromptHydrateFlow();\n  }, [\n    trackedMeasurements,\n    activeViewportId,\n    sendTrackedMeasurementsEvent,\n    servicesManager.services,\n    viewports,\n    appConfig,\n  ]);\n\n  useEffect(() => {\n    // The command needs to be bound to the context's sendTrackedMeasurementsEvent\n    // so the command has to be registered in a React component.\n    commandsManager.registerCommand('DEFAULT', 'loadTrackedSRMeasurements', {\n      commandFn: props => sendTrackedMeasurementsEvent('HYDRATE_SR', props),\n    });\n  }, [commandsManager, sendTrackedMeasurementsEvent]);\n\n  return (\n    <TrackedMeasurementsContext.Provider\n      value={[trackedMeasurements, sendTrackedMeasurementsEvent]}\n    >\n      {children}\n    </TrackedMeasurementsContext.Provider>\n  );\n}\n\nTrackedMeasurementsContextProvider.propTypes = {\n  children: PropTypes.oneOf([PropTypes.func, PropTypes.node]),\n  appConfig: PropTypes.object,\n};\n\nexport { TrackedMeasurementsContext, TrackedMeasurementsContextProvider, useTrackedMeasurements };\n","import { hydrateStructuredReport as baseHydrateStructuredReport } from '@ohif/extension-cornerstone-dicom-sr';\n\nfunction hydrateStructuredReport(\n  { servicesManager, extensionManager, commandsManager, appConfig }: withAppTypes,\n  ctx,\n  evt\n) {\n  const { displaySetService } = servicesManager.services;\n  const { viewportId, displaySetInstanceUID } = evt;\n  const srDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  return new Promise((resolve, reject) => {\n    const hydrationResult = baseHydrateStructuredReport(\n      { servicesManager, extensionManager, commandsManager, appConfig },\n      displaySetInstanceUID\n    );\n\n    const StudyInstanceUID = hydrationResult.StudyInstanceUID;\n    const SeriesInstanceUIDs = hydrationResult.SeriesInstanceUIDs;\n\n    resolve({\n      displaySetInstanceUID: evt.displaySetInstanceUID,\n      srSeriesInstanceUID: srDisplaySet.SeriesInstanceUID,\n      viewportId,\n      StudyInstanceUID,\n      SeriesInstanceUIDs,\n    });\n  });\n}\n\nexport default hydrateStructuredReport;\n","export {\n  TrackedMeasurementsContext,\n  TrackedMeasurementsContextProvider,\n  useTrackedMeasurements,\n} from './TrackedMeasurementsContext.tsx';\n","import { assign } from 'xstate';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n  HYDRATE_REPORT: 5,\n};\n\nconst machineConfiguration = {\n  id: 'measurementTracking',\n  initial: 'idle',\n  context: {\n    activeViewportId: null,\n    trackedStudy: '',\n    trackedSeries: [],\n    ignoredSeries: [],\n    //\n    prevTrackedStudy: '',\n    prevTrackedSeries: [],\n    prevIgnoredSeries: [],\n    //\n    ignoredSRSeriesForHydration: [],\n    isDirty: false,\n  },\n  states: {\n    off: {\n      type: 'final',\n    },\n    labellingOnly: {\n      on: {\n        TRACK_SERIES: [\n          {\n            target: 'promptLabelAnnotation',\n            actions: ['setPreviousState'],\n          },\n          {\n            target: 'off',\n          },\n        ],\n      },\n    },\n    idle: {\n      entry: 'clearContext',\n      on: {\n        TRACK_SERIES: [\n          {\n            target: 'promptLabelAnnotation',\n            cond: 'isLabelOnMeasure',\n            actions: ['setPreviousState'],\n          },\n          {\n            target: 'promptBeginTracking',\n            actions: ['setPreviousState'],\n          },\n        ],\n        SET_TRACKED_SERIES: [\n          {\n            target: 'tracking',\n            actions: ['setTrackedStudyAndMultipleSeries', 'setIsDirtyToClean'],\n          },\n        ],\n        PROMPT_HYDRATE_SR: {\n          target: 'promptHydrateStructuredReport',\n          cond: 'hasNotIgnoredSRSeriesForHydration',\n        },\n        RESTORE_PROMPT_HYDRATE_SR: 'promptHydrateStructuredReport',\n        HYDRATE_SR: 'hydrateStructuredReport',\n        UPDATE_ACTIVE_VIEWPORT_ID: {\n          actions: assign({\n            activeViewportId: (_, event) => event.activeViewportId,\n          }),\n        },\n      },\n    },\n    promptBeginTracking: {\n      invoke: {\n        src: 'promptBeginTracking',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: ['setTrackedStudyAndSeries', 'setIsDirty'],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'labellingOnly',\n            cond: 'isLabelOnMeasureAndShouldKillMachine',\n          },\n          {\n            target: 'off',\n            cond: 'shouldKillMachine',\n          },\n          {\n            target: 'idle',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    tracking: {\n      on: {\n        TRACK_SERIES: [\n          {\n            target: 'promptLabelAnnotation',\n            cond: 'isLabelOnMeasure',\n            actions: ['setPreviousState'],\n          },\n          {\n            target: 'promptTrackNewStudy',\n            cond: 'isNewStudy',\n          },\n          {\n            target: 'promptTrackNewSeries',\n            cond: 'isNewSeries',\n          },\n        ],\n        UNTRACK_SERIES: [\n          {\n            target: 'tracking',\n            actions: ['removeTrackedSeries', 'setIsDirty', 'clearDisplaySetHydratedState'],\n            cond: 'hasRemainingTrackedSeries',\n          },\n          {\n            target: 'idle',\n          },\n        ],\n        UNTRACK_ALL: [\n          {\n            target: 'tracking',\n            actions: [\n              'clearContext',\n              'setIsDirtyToClean',\n              'clearDisplaySetHydratedState',\n              'clearAllMeasurements',\n            ],\n          },\n          {\n            target: 'idle',\n          },\n        ],\n        SET_TRACKED_SERIES: [\n          {\n            target: 'tracking',\n            actions: ['setTrackedStudyAndMultipleSeries'],\n          },\n        ],\n        SAVE_REPORT: 'promptSaveReport',\n        SET_DIRTY: [\n          {\n            target: 'tracking',\n            actions: ['setIsDirty'],\n            cond: 'shouldSetDirty',\n          },\n          {\n            target: 'tracking',\n          },\n        ],\n        CHECK_DIRTY: {\n          target: 'promptHasDirtyAnnotations',\n          cond: 'hasDirtyAndSimplified',\n        },\n        PROMPT_HYDRATE_SR: {\n          target: 'promptHydrateStructuredReport',\n          cond: 'isSimplifiedConfig',\n          actions: ['clearAllMeasurements', 'clearDisplaySetHydratedState'],\n        },\n      },\n    },\n    promptTrackNewSeries: {\n      invoke: {\n        src: 'promptTrackNewSeries',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: ['addTrackedSeries', 'setIsDirty'],\n            cond: 'shouldAddSeries',\n          },\n          {\n            target: 'tracking',\n            actions: [\n              'discardPreviouslyTrackedMeasurements',\n              'setTrackedStudyAndSeries',\n              'setIsDirty',\n            ],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'promptSaveReport',\n            cond: 'shouldPromptSaveReport',\n          },\n          {\n            target: 'tracking',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptTrackNewStudy: {\n      invoke: {\n        src: 'promptTrackNewStudy',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'discardPreviouslyTrackedMeasurements',\n              'setTrackedStudyAndSeries',\n              'setIsDirty',\n            ],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'tracking',\n            actions: ['ignoreSeries'],\n            cond: 'shouldAddIgnoredSeries',\n          },\n          {\n            target: 'promptSaveReport',\n            cond: 'shouldPromptSaveReport',\n          },\n          {\n            target: 'tracking',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptSaveReport: {\n      invoke: {\n        src: 'promptSaveReport',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'clearAllMeasurements',\n              'clearDisplaySetHydratedState',\n              'setIsDirty',\n              'updatedViewports',\n            ],\n            cond: 'simplifiedAndLoadSR',\n          },\n          // \"clicked the save button\"\n          // - should clear all measurements\n          // - show DICOM SR\n          {\n            target: 'idle',\n            actions: ['clearAllMeasurements', 'showStructuredReportDisplaySetInActiveViewport'],\n            cond: 'shouldSaveAndContinueWithSameReport',\n          },\n          // \"starting a new report\"\n          // - remove \"just saved\" measurements\n          // - start tracking a new study + report\n          {\n            target: 'tracking',\n            actions: ['discardPreviouslyTrackedMeasurements', 'setTrackedStudyAndSeries'],\n            cond: 'shouldSaveAndStartNewReport',\n          },\n          // Cancel, back to tracking\n          {\n            target: 'tracking',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptHydrateStructuredReport: {\n      invoke: {\n        src: 'promptHydrateStructuredReport',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'setTrackedStudyAndMultipleSeries',\n              'jumpToSameImageInActiveViewport',\n              'setIsDirtyToClean',\n            ],\n            cond: 'shouldHydrateStructuredReport',\n          },\n          {\n            target: 'idle',\n            actions: ['ignoreHydrationForSRSeries'],\n            cond: 'shouldIgnoreHydrationForSR',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    hydrateStructuredReport: {\n      invoke: {\n        src: 'hydrateStructuredReport',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'setTrackedStudyAndMultipleSeries',\n              'jumpToSameImageInActiveViewport',\n              'setIsDirtyToClean',\n            ],\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptLabelAnnotation: {\n      invoke: {\n        src: 'promptLabelAnnotation',\n        onDone: [\n          {\n            target: 'labellingOnly',\n            cond: 'wasLabellingOnly',\n          },\n          {\n            target: 'promptBeginTracking',\n            cond: 'wasIdle',\n          },\n          {\n            target: 'promptTrackNewStudy',\n            cond: 'wasTrackingAndIsNewStudy',\n          },\n          {\n            target: 'promptTrackNewSeries',\n            cond: 'wasTrackingAndIsNewSeries',\n          },\n          {\n            target: 'tracking',\n            cond: 'wasTracking',\n          },\n          {\n            target: 'off',\n          },\n        ],\n      },\n    },\n    promptHasDirtyAnnotations: {\n      invoke: {\n        src: 'promptHasDirtyAnnotations',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'clearAllMeasurements',\n              'clearDisplaySetHydratedState',\n              'setIsDirty',\n              'updatedViewports',\n            ],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'promptSaveReport',\n            cond: 'shouldPromptSaveReport',\n          },\n          { target: 'tracking' },\n        ],\n      },\n    },\n  },\n  strict: true,\n};\n\nconst defaultOptions = {\n  services: {\n    promptBeginTracking: (ctx, evt) => {\n      // return { userResponse, StudyInstanceUID, SeriesInstanceUID }\n    },\n    promptTrackNewStudy: (ctx, evt) => {\n      // return { userResponse, StudyInstanceUID, SeriesInstanceUID }\n    },\n    promptTrackNewSeries: (ctx, evt) => {\n      // return { userResponse, StudyInstanceUID, SeriesInstanceUID }\n    },\n  },\n  actions: {\n    discardPreviouslyTrackedMeasurements: (ctx, evt) => {\n      console.log('discardPreviouslyTrackedMeasurements: not implemented');\n    },\n    clearAllMeasurements: (ctx, evt) => {\n      console.log('clearAllMeasurements: not implemented');\n    },\n    jumpToFirstMeasurementInActiveViewport: (ctx, evt) => {\n      console.warn('jumpToFirstMeasurementInActiveViewport: not implemented');\n    },\n    showStructuredReportDisplaySetInActiveViewport: (ctx, evt) => {\n      console.warn('showStructuredReportDisplaySetInActiveViewport: not implemented');\n    },\n    clearContext: assign({\n      trackedStudy: '',\n      trackedSeries: [],\n      ignoredSeries: [],\n      prevTrackedStudy: '',\n      prevTrackedSeries: [],\n      prevIgnoredSeries: [],\n    }),\n    // Promise resolves w/ `evt.data.*`\n    setTrackedStudyAndSeries: assign((ctx, evt) => ({\n      prevTrackedStudy: ctx.trackedStudy,\n      prevTrackedSeries: ctx.trackedSeries.slice(),\n      prevIgnoredSeries: ctx.ignoredSeries.slice(),\n      //\n      trackedStudy: evt.data.StudyInstanceUID,\n      trackedSeries: [evt.data.SeriesInstanceUID],\n      ignoredSeries: [],\n    })),\n    setTrackedStudyAndMultipleSeries: assign((ctx, evt) => {\n      const studyInstanceUID = evt.StudyInstanceUID || evt.data.StudyInstanceUID;\n      const seriesInstanceUIDs = evt.SeriesInstanceUIDs || evt.data.SeriesInstanceUIDs;\n\n      return {\n        prevTrackedStudy: ctx.trackedStudy,\n        prevTrackedSeries: ctx.trackedSeries.slice(),\n        prevIgnoredSeries: ctx.ignoredSeries.slice(),\n        //\n        trackedStudy: studyInstanceUID,\n        trackedSeries: [...ctx.trackedSeries, ...seriesInstanceUIDs],\n        ignoredSeries: [],\n      };\n    }),\n    setIsDirtyToClean: assign((ctx, evt) => ({\n      isDirty: false,\n    })),\n    setIsDirty: assign((ctx, evt) => ({\n      isDirty: true,\n    })),\n    ignoreSeries: assign((ctx, evt) => ({\n      prevIgnoredSeries: [...ctx.ignoredSeries],\n      ignoredSeries: [...ctx.ignoredSeries, evt.data.SeriesInstanceUID],\n    })),\n    ignoreHydrationForSRSeries: assign((ctx, evt) => ({\n      ignoredSRSeriesForHydration: [\n        ...ctx.ignoredSRSeriesForHydration,\n        evt.data.srSeriesInstanceUID,\n      ],\n    })),\n    addTrackedSeries: assign((ctx, evt) => ({\n      prevTrackedSeries: [...ctx.trackedSeries],\n      trackedSeries: [...ctx.trackedSeries, evt.data.SeriesInstanceUID],\n    })),\n    removeTrackedSeries: assign((ctx, evt) => ({\n      prevTrackedSeries: ctx.trackedSeries.slice().filter(ser => ser !== evt.SeriesInstanceUID),\n      trackedSeries: ctx.trackedSeries.slice().filter(ser => ser !== evt.SeriesInstanceUID),\n    })),\n    setPreviousState: assign((ctx, evt, meta) => {\n      return {\n        prevState: meta.state.value,\n      };\n    }),\n  },\n  guards: {\n    // We set dirty any time we performan an action that:\n    // - Tracks a new study\n    // - Tracks a new series\n    // - Adds a measurement to an already tracked study/series\n    //\n    // We set clean any time we restore from an SR\n    //\n    // This guard/condition is specific to \"new measurements\"\n    // to make sure we only track dirty when the new measurement is specific\n    // to a series we're already tracking\n    //\n    // tl;dr\n    // Any report change, that is not a hydration of an existing report, should\n    // result in a \"dirty\" report\n    //\n    // Where dirty means there would be \"loss of data\" if we blew away measurements\n    // without creating a new SR.\n    shouldSetDirty: (ctx, evt) => {\n      return (\n        // When would this happen?\n        evt.SeriesInstanceUID === undefined || ctx.trackedSeries.includes(evt.SeriesInstanceUID)\n      );\n    },\n    wasLabellingOnly: (ctx, evt, condMeta) => {\n      return ctx.prevState === 'labellingOnly';\n    },\n    wasIdle: (ctx, evt, condMeta) => {\n      return ctx.prevState === 'idle';\n    },\n    wasTracking: (ctx, evt, condMeta) => {\n      return ctx.prevState === 'tracking';\n    },\n    wasTrackingAndIsNewStudy: (ctx, evt, condMeta) => {\n      return (\n        ctx.prevState === 'tracking' &&\n        !ctx.ignoredSeries.includes(evt.data.SeriesInstanceUID) &&\n        ctx.trackedStudy !== evt.data.StudyInstanceUID\n      );\n    },\n    wasTrackingAndIsNewSeries: (ctx, evt, condMeta) => {\n      return (\n        ctx.prevState === 'tracking' &&\n        !ctx.ignoredSeries.includes(evt.data.SeriesInstanceUID) &&\n        !ctx.trackedSeries.includes(evt.data.SeriesInstanceUID)\n      );\n    },\n\n    shouldKillMachine: (ctx, evt) => evt.data && evt.data.userResponse === RESPONSE.NO_NEVER,\n    shouldAddSeries: (ctx, evt) => evt.data && evt.data.userResponse === RESPONSE.ADD_SERIES,\n    shouldSetStudyAndSeries: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.SET_STUDY_AND_SERIES,\n    shouldAddIgnoredSeries: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.NO_NOT_FOR_SERIES,\n    shouldPromptSaveReport: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.CREATE_REPORT,\n    shouldIgnoreHydrationForSR: (ctx, evt) => evt.data && evt.data.userResponse === RESPONSE.CANCEL,\n    shouldSaveAndContinueWithSameReport: (ctx, evt) =>\n      evt.data &&\n      evt.data.userResponse === RESPONSE.CREATE_REPORT &&\n      evt.data.isBackupSave === true,\n    shouldSaveAndStartNewReport: (ctx, evt) =>\n      evt.data &&\n      evt.data.userResponse === RESPONSE.CREATE_REPORT &&\n      evt.data.isBackupSave === false,\n    shouldHydrateStructuredReport: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.HYDRATE_REPORT,\n    // Has more than 1, or SeriesInstanceUID is not in list\n    // --> Post removal would have non-empty trackedSeries array\n    hasRemainingTrackedSeries: (ctx, evt) =>\n      ctx.trackedSeries.length > 1 || !ctx.trackedSeries.includes(evt.SeriesInstanceUID),\n    hasNotIgnoredSRSeriesForHydration: (ctx, evt) => {\n      return !ctx.ignoredSRSeriesForHydration.includes(evt.SeriesInstanceUID);\n    },\n    isNewStudy: (ctx, evt) =>\n      !ctx.ignoredSeries.includes(evt.SeriesInstanceUID) &&\n      ctx.trackedStudy !== evt.StudyInstanceUID,\n    isNewSeries: (ctx, evt) =>\n      !ctx.ignoredSeries.includes(evt.SeriesInstanceUID) &&\n      !ctx.trackedSeries.includes(evt.SeriesInstanceUID),\n  },\n};\n\nexport { defaultOptions, machineConfiguration, RESPONSE };\n","import i18n from 'i18next';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n};\n\nexport const measurementTrackingMode = {\n  STANDARD: 'standard',\n  SIMPLIFIED: 'simplified',\n  NONE: 'none',\n};\n\nfunction promptBeginTracking({ servicesManager, extensionManager }, ctx, evt) {\n  const { uiViewportDialogService, customizationService } = servicesManager.services;\n  const appConfig = extensionManager._appConfig;\n  // When the state change happens after a promise, the state machine sends the retult in evt.data;\n  // In case of direct transition to the state, the state machine sends the data in evt;\n  const { viewportId, StudyInstanceUID, SeriesInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const standardMode = appConfig?.measurementTrackingMode === measurementTrackingMode.STANDARD;\n    const noTrackingMode = appConfig?.measurementTrackingMode === measurementTrackingMode.NONE;\n    let promptResult;\n\n    promptResult = noTrackingMode\n      ? RESPONSE.NO_NEVER\n      : standardMode\n        ? await _askTrackMeasurements(uiViewportDialogService, customizationService, viewportId)\n        : RESPONSE.SET_STUDY_AND_SERIES;\n\n    resolve({\n      userResponse: promptResult,\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      viewportId,\n    });\n  });\n}\n\nfunction _askTrackMeasurements(uiViewportDialogService, customizationService, viewportId) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.beginTrackingMessage'\n    );\n    const actions = [\n      {\n        id: 'prompt-begin-tracking-cancel',\n        type: 'secondary',\n        text: i18n.t('Common:No'),\n        value: RESPONSE.CANCEL,\n      },\n      {\n        id: 'prompt-begin-tracking-no-do-not-ask-again',\n        type: 'secondary',\n        text: i18n.t('MeasurementTable:No, do not ask again'),\n        value: RESPONSE.NO_NEVER,\n      },\n      {\n        id: 'prompt-begin-tracking-yes',\n        type: 'primary',\n        text: i18n.t('Common:Yes'),\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      uiViewportDialogService.hide();\n      resolve(result);\n    };\n\n    uiViewportDialogService.show({\n      viewportId,\n      id: 'measurement-tracking-prompt-begin-tracking',\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        uiViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n      onKeyPress: event => {\n        if (event.key === 'Enter') {\n          const action = actions.find(action => action.id === 'prompt-begin-tracking-yes');\n          onSubmit(action.value);\n        }\n      },\n    });\n  });\n}\n\nexport default promptBeginTracking;\n","const RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n};\n\nfunction promptHasDirtyAnnotations({ servicesManager }: withAppTypes, ctx, evt) {\n  const { viewportId, displaySetInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const { uiViewportDialogService, customizationService } = servicesManager.services;\n\n    const promptResult = await _askSaveDiscardOrCancel(\n      uiViewportDialogService,\n      customizationService,\n      viewportId\n    );\n\n    resolve({\n      displaySetInstanceUID,\n      userResponse: promptResult,\n      viewportId,\n      isBackupSave: false,\n    });\n  });\n}\n\nfunction _askSaveDiscardOrCancel(\n  UIViewportDialogService: AppTypes.UIViewportDialogService,\n  customizationService: AppTypes.CustomizationService,\n  viewportId\n) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.discardDirtyMessage'\n    );\n    const actions = [\n      { id: 'cancel', type: 'cancel', text: 'Cancel', value: RESPONSE.CANCEL },\n      {\n        id: 'discard-existing',\n        type: 'secondary',\n        text: 'No, discard existing',\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n      {\n        id: 'save-existing',\n        type: 'primary',\n        text: 'Yes',\n        value: RESPONSE.CREATE_REPORT,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      id: 'measurement-tracking-prompt-dirty-measurement',\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n      onKeyPress: event => {\n        if (event.key === 'Enter') {\n          const action = actions.find(action => action.id === 'save-existing');\n          onSubmit(action.value);\n        }\n      },\n    });\n  });\n}\n\nexport default promptHasDirtyAnnotations;\n","import { utils } from '@ohif/extension-cornerstone';\n\nfunction promptHydrateStructuredReport({ servicesManager, commandsManager }, ctx, evt) {\n  const { displaySetService } = servicesManager.services;\n  const { viewportId, displaySetInstanceUID } = evt;\n  const srDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  const hydrateCallback = async () => {\n    return commandsManager.runCommand('hydrateSecondaryDisplaySet', {\n      displaySet: srDisplaySet,\n      viewportId,\n    });\n  };\n\n  // For SR we need to use the whole context\n  const enhancedSrDisplaySet = {\n    ...srDisplaySet,\n    displaySetInstanceUID,\n  };\n\n  return utils.promptHydrationDialog({\n    servicesManager,\n    viewportId,\n    displaySet: enhancedSrDisplaySet,\n    hydrateCallback,\n    type: 'SR',\n  });\n}\n\nexport default promptHydrateStructuredReport;\n","import { measurementTrackingMode } from './promptBeginTracking';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n};\n\nfunction promptTrackNewSeries({ servicesManager, extensionManager }, ctx, evt) {\n  const { UIViewportDialogService, customizationService } = servicesManager.services;\n  // When the state change happens after a promise, the state machine sends the retult in evt.data;\n  // In case of direct transition to the state, the state machine sends the data in evt;\n  const { viewportId, StudyInstanceUID, SeriesInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const appConfig = extensionManager._appConfig;\n\n    const showPrompt = appConfig?.measurementTrackingMode === measurementTrackingMode.STANDARD;\n    let promptResult = showPrompt\n      ? await _askShouldAddMeasurements(UIViewportDialogService, customizationService, viewportId)\n      : RESPONSE.ADD_SERIES;\n\n    if (promptResult === RESPONSE.CREATE_REPORT) {\n      promptResult = ctx.isDirty\n        ? await _askSaveDiscardOrCancel(UIViewportDialogService, customizationService, viewportId)\n        : RESPONSE.SET_STUDY_AND_SERIES;\n    }\n\n    resolve({\n      userResponse: promptResult,\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      viewportId,\n      isBackupSave: false,\n    });\n  });\n}\n\nfunction _askShouldAddMeasurements(uiViewportDialogService, customizationService, viewportId) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.trackNewSeriesMessage'\n    );\n    const actions = [\n      {\n        type: 'secondary',\n        text: 'Cancel',\n        value: RESPONSE.CANCEL,\n      },\n      {\n        type: 'primary',\n        text: 'Create new report',\n        value: RESPONSE.CREATE_REPORT,\n      },\n      {\n        type: 'primary',\n        text: 'Add to existing report',\n        value: RESPONSE.ADD_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      uiViewportDialogService.hide();\n      resolve(result);\n    };\n\n    uiViewportDialogService.show({\n      viewportId,\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        uiViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n    });\n  });\n}\n\nfunction _askSaveDiscardOrCancel(UIViewportDialogService, customizationService, viewportId) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.discardSeriesMessage'\n    );\n\n    const actions = [\n      { type: 'secondary', text: 'Cancel', value: RESPONSE.CANCEL },\n      {\n        type: 'secondary',\n        text: 'Save',\n        value: RESPONSE.CREATE_REPORT,\n      },\n      {\n        type: 'primary',\n        text: 'Discard',\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      type: 'warning',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n    });\n  });\n}\n\nexport default promptTrackNewSeries;\n","import i18n from 'i18next';\nimport { measurementTrackingMode } from './promptBeginTracking';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n};\n\nfunction promptTrackNewStudy({ servicesManager, extensionManager }: withAppTypes, ctx, evt) {\n  const { uiViewportDialogService, customizationService } = servicesManager.services;\n  // When the state change happens after a promise, the state machine sends the retult in evt.data;\n  // In case of direct transition to the state, the state machine sends the data in evt;\n  const { viewportId, StudyInstanceUID, SeriesInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const appConfig = extensionManager._appConfig;\n\n    const standardMode = appConfig?.measurementTrackingMode === measurementTrackingMode.STANDARD;\n    const simplifiedMode =\n      appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED;\n    let promptResult = standardMode\n      ? await _askTrackMeasurements(uiViewportDialogService, customizationService, viewportId)\n      : RESPONSE.SET_STUDY_AND_SERIES;\n\n    if (promptResult === RESPONSE.SET_STUDY_AND_SERIES) {\n      promptResult =\n        ctx.isDirty && (standardMode || simplifiedMode)\n          ? await _askSaveDiscardOrCancel(uiViewportDialogService, customizationService, viewportId)\n          : RESPONSE.SET_STUDY_AND_SERIES;\n    }\n\n    resolve({\n      userResponse: promptResult,\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      viewportId,\n      isBackupSave: false,\n    });\n  });\n}\n\nfunction _askTrackMeasurements(\n  UIViewportDialogService: AppTypes.UIViewportDialogService,\n  customizationService: AppTypes.CustomizationService,\n  viewportId\n) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.trackNewStudyMessage'\n    );\n    const actions = [\n      { type: 'cancel', text: i18n.t('MeasurementTable:No'), value: RESPONSE.CANCEL },\n      {\n        type: 'secondary',\n        text: i18n.t('MeasurementTable:No, do not ask again'),\n        value: RESPONSE.NO_NOT_FOR_SERIES,\n      },\n      {\n        type: 'primary',\n        text: i18n.t('MeasurementTable:Yes'),\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n      onKeyPress: event => {\n        if (event.key === 'Enter') {\n          const action = actions.find(action => action.value === RESPONSE.SET_STUDY_AND_SERIES);\n          onSubmit(action.value);\n        }\n      },\n    });\n  });\n}\n\nfunction _askSaveDiscardOrCancel(\n  UIViewportDialogService: AppTypes.UIViewportDialogService,\n  customizationService: AppTypes.CustomizationService,\n  viewportId\n) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.discardStudyMessage'\n    );\n    const actions = [\n      { type: 'cancel', text: 'Cancel', value: RESPONSE.CANCEL },\n      {\n        type: 'secondary',\n        text: 'No, discard previously tracked series & measurements',\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n      {\n        type: 'primary',\n        text: 'Yes',\n        value: RESPONSE.CREATE_REPORT,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      type: 'warning',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n    });\n  });\n}\n\nexport default promptTrackNewStudy;\n","const promptBeginTrackingWrapper = ({ servicesManager, extensionManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptBeginTracking = customizationService.getCustomization(\n    'measurement.promptBeginTracking'\n  );\n  return promptBeginTracking({ servicesManager, extensionManager }, ctx, evt);\n};\n\nconst promptHydrateStructuredReportWrapper = (\n  { servicesManager, extensionManager, commandsManager, appConfig },\n  ctx,\n  evt\n) => {\n  const { customizationService } = servicesManager.services;\n  const promptHydrateStructuredReport = customizationService.getCustomization(\n    'measurement.promptHydrateStructuredReport'\n  );\n  return promptHydrateStructuredReport(\n    { servicesManager, extensionManager, commandsManager, appConfig },\n    ctx,\n    evt\n  );\n};\n\nconst promptTrackNewSeriesWrapper = ({ servicesManager, extensionManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptTrackNewSeries = customizationService.getCustomization(\n    'measurement.promptTrackNewSeries'\n  );\n  return promptTrackNewSeries({ servicesManager, extensionManager }, ctx, evt);\n};\n\nconst promptTrackNewStudyWrapper = ({ servicesManager, extensionManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptTrackNewStudy = customizationService.getCustomization(\n    'measurement.promptTrackNewStudy'\n  );\n  return promptTrackNewStudy({ servicesManager, extensionManager }, ctx, evt);\n};\n\nconst promptLabelAnnotationWrapper = ({ servicesManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptLabelAnnotation = customizationService.getCustomization(\n    'measurement.promptLabelAnnotation'\n  );\n  return promptLabelAnnotation({ servicesManager }, ctx, evt);\n};\n\nconst promptSaveReportWrapper = (\n  { servicesManager, commandsManager, extensionManager },\n  ctx,\n  evt\n) => {\n  const { customizationService } = servicesManager.services;\n  const promptSaveReport = customizationService.getCustomization('measurement.promptSaveReport');\n  return promptSaveReport({ servicesManager, commandsManager, extensionManager }, ctx, evt);\n};\n\nconst promptHasDirtyAnnotationsWrapper = (\n  { servicesManager, commandsManager, extensionManager },\n  ctx,\n  evt\n) => {\n  const { customizationService } = servicesManager.services;\n  const promptHasDirtyAnnotations = customizationService.getCustomization(\n    'measurement.promptHasDirtyAnnotations'\n  );\n  return promptHasDirtyAnnotations(\n    { servicesManager, commandsManager, extensionManager },\n    ctx,\n    evt\n  );\n};\n\nexport {\n  promptBeginTrackingWrapper,\n  promptHydrateStructuredReportWrapper,\n  promptTrackNewSeriesWrapper,\n  promptTrackNewStudyWrapper,\n  promptLabelAnnotationWrapper,\n  promptSaveReportWrapper,\n  promptHasDirtyAnnotationsWrapper,\n};\n","export {\n  TrackedMeasurementsContext,\n  TrackedMeasurementsContextProvider,\n  useTrackedMeasurements,\n} from './TrackedMeasurementsContext';\n","import promptBeginTracking from '../contexts/TrackedMeasurementsContext/promptBeginTracking';\nimport promptHasDirtyAnnotations from '../contexts/TrackedMeasurementsContext/promptHasDirtyAnnotations';\nimport promptHydrateStructuredReport from '../contexts/TrackedMeasurementsContext/promptHydrateStructuredReport';\nimport promptTrackNewSeries from '../contexts/TrackedMeasurementsContext/promptTrackNewSeries';\nimport promptTrackNewStudy from '../contexts/TrackedMeasurementsContext/promptTrackNewStudy';\nimport { promptLabelAnnotation, promptSaveReport } from '@ohif/extension-default';\n\nexport default {\n  'measurement.promptBeginTracking': promptBeginTracking,\n  'measurement.promptHydrateStructuredReport': promptHydrateStructuredReport,\n  'measurement.promptTrackNewSeries': promptTrackNewSeries,\n  'measurement.promptTrackNewStudy': promptTrackNewStudy,\n  'measurement.promptLabelAnnotation': promptLabelAnnotation,\n  'measurement.promptSaveReport': promptSaveReport,\n  'measurement.promptHasDirtyAnnotations': promptHasDirtyAnnotations,\n};\n","import { measurementTrackingMode } from '../contexts/TrackedMeasurementsContext/promptBeginTracking';\n\ntype CheckHasDirtyAndSimplifiedModeProps = {\n  servicesManager: AppTypes.ServicesManager;\n  appConfig: AppTypes.Config;\n  displaySetInstanceUID: string;\n};\n\nconst onDoubleClickHandler = {\n  callbacks: [\n    ({ activeViewportId, servicesManager, isHangingProtocolLayout, appConfig }) =>\n      async displaySetInstanceUID => {\n        const { hangingProtocolService, viewportGridService, uiNotificationService } =\n          servicesManager.services;\n        let updatedViewports = [];\n        const viewportId = activeViewportId;\n        const haveDirtyMeasurementsInSimplifiedMode = checkHasDirtyAndSimplifiedMode({\n          servicesManager,\n          appConfig,\n          displaySetInstanceUID,\n        });\n\n        try {\n          if (!haveDirtyMeasurementsInSimplifiedMode) {\n            updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n              viewportId,\n              displaySetInstanceUID,\n              isHangingProtocolLayout\n            );\n            viewportGridService.setDisplaySetsForViewports(updatedViewports);\n          }\n        } catch (error) {\n          console.warn(error);\n          uiNotificationService.show({\n            title: 'Thumbnail Double Click',\n            message: 'The selected display sets could not be added to the viewport.',\n            type: 'error',\n            duration: 3000,\n          });\n        }\n      },\n  ],\n};\n\nconst customOnDropHandlerCallback = async props => {\n  const handled = checkHasDirtyAndSimplifiedMode(props);\n  return Promise.resolve({ handled });\n};\n\nconst checkHasDirtyAndSimplifiedMode = (props: CheckHasDirtyAndSimplifiedModeProps) => {\n  const { servicesManager, appConfig, displaySetInstanceUID } = props;\n  const simplifiedMode = appConfig.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED;\n  const { measurementService, displaySetService } = servicesManager.services;\n  const measurements = measurementService.getMeasurements();\n  const haveDirtyMeasurements =\n    measurements.some(m => m.isDirty) ||\n    (measurements.length && measurementService.getIsMeasurementDeletedIndividually());\n  const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n  const hasDirtyAndSimplifiedMode =\n    displaySet.Modality === 'SR' && simplifiedMode && haveDirtyMeasurements;\n  return hasDirtyAndSimplifiedMode;\n};\n\nexport { onDoubleClickHandler, customOnDropHandlerCallback };\n","import {\n  TrackedMeasurementsContext,\n  TrackedMeasurementsContextProvider,\n  useTrackedMeasurements,\n} from './contexts';\n\nfunction getContextModule({ servicesManager, extensionManager, commandsManager }) {\n  const BoundTrackedMeasurementsContextProvider = TrackedMeasurementsContextProvider.bind(null, {\n    servicesManager,\n    extensionManager,\n    commandsManager,\n  });\n\n  return [\n    {\n      name: 'TrackedMeasurementsContext',\n      context: TrackedMeasurementsContext,\n      provider: BoundTrackedMeasurementsContextProvider,\n    },\n  ];\n}\n\nexport { useTrackedMeasurements };\nexport default getContextModule;\n","import measurementTrackingPrompts from './customizations/measurementTrackingPrompts';\n\nexport default function getCustomizationModule() {\n  return [\n    {\n      name: 'default',\n      value: { ...measurementTrackingPrompts },\n    },\n  ];\n}\n","import { Types } from '@ohif/core';\nimport { PanelMeasurementTableTracking, PanelStudyBrowserTracking } from './panels';\nimport i18n from 'i18next';\nimport React from 'react';\n\n// TODO:\n// - No loading UI exists yet\n// - cancel promises when component is destroyed\n// - show errors in UI for thumbnails if promise fails\n\nfunction getPanelModule({ commandsManager, extensionManager, servicesManager }): Types.Panel[] {\n  return [\n    {\n      name: 'seriesList',\n      iconName: 'tab-studies',\n      iconLabel: 'Studies',\n      label: i18n.t('SidePanel:Studies'),\n      component: props => <PanelStudyBrowserTracking {...props} />,\n    },\n    {\n      name: 'trackedMeasurements',\n      iconName: 'tab-linear',\n      iconLabel: 'Measure',\n      label: i18n.t('SidePanel:Measurements'),\n      component: props => (\n        <PanelMeasurementTableTracking\n          {...props}\n          key=\"trackedMeasurements-panel\"\n          commandsManager={commandsManager}\n          extensionManager={extensionManager}\n          servicesManager={servicesManager}\n        />\n      ),\n    },\n  ];\n}\n\nexport default getPanelModule;\n","import React from 'react';\nimport { utils } from '@ohif/extension-cornerstone';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './viewports/TrackedCornerstoneViewport');\n});\n\nconst OHIFCornerstoneViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\nfunction getViewportModule({ servicesManager, commandsManager, extensionManager }) {\n  const ExtendedOHIFCornerstoneTrackingViewport = props => {\n    return (\n      <OHIFCornerstoneViewport\n        servicesManager={servicesManager}\n        commandsManager={commandsManager}\n        extensionManager={extensionManager}\n        {...props}\n      />\n    );\n  };\n\n  return [\n    {\n      name: 'cornerstone-tracked',\n      component: ExtendedOHIFCornerstoneTrackingViewport,\n      isReferenceViewable: props => utils.isReferenceViewable({ ...props, servicesManager }),\n    },\n  ];\n}\n\nexport default getViewportModule;\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nexport { id };\n","import getContextModule from './getContextModule';\nimport getPanelModule from './getPanelModule';\nimport getViewportModule from './getViewportModule';\nimport { id } from './id.js';\nimport { measurementTrackingMode } from './contexts/TrackedMeasurementsContext/promptBeginTracking';\nimport getCustomizationModule from './getCustomizationModule';\nimport {\n  onDoubleClickHandler,\n  customOnDropHandlerCallback,\n} from './customizations/studyBrowserCustomization';\nimport { TrackedMeasurementsService } from './services';\n// Import types to ensure they're included in the build\nimport './types';\n\nconst measurementTrackingExtension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n\n  getContextModule,\n  getPanelModule,\n  getViewportModule,\n\n  /**\n   * Service configuration\n   */\n  preRegistration({ servicesManager }) {\n    servicesManager.registerService(TrackedMeasurementsService.REGISTRATION);\n  },\n\n  onModeEnter({ servicesManager }) {\n    const { customizationService, toolbarService, trackedMeasurementsService } =\n      servicesManager.services;\n\n    toolbarService.registerEventForToolbarUpdate(trackedMeasurementsService, [\n      trackedMeasurementsService.EVENTS.TRACKED_SERIES_CHANGED,\n      trackedMeasurementsService.EVENTS.SERIES_ADDED,\n      trackedMeasurementsService.EVENTS.SERIES_REMOVED,\n      trackedMeasurementsService.EVENTS.TRACKING_ENABLED,\n      trackedMeasurementsService.EVENTS.TRACKING_DISABLED,\n    ]);\n\n    customizationService.setCustomizations({\n      'studyBrowser.thumbnailDoubleClickCallback': {\n        $set: onDoubleClickHandler,\n      },\n      customOnDropHandler: {\n        $set: customOnDropHandlerCallback,\n      },\n    });\n  },\n  getCustomizationModule,\n};\n\nexport default measurementTrackingExtension;\n\nexport { measurementTrackingMode };\n","import React from 'react';\nimport { useSystem, utils } from '@ohif/core';\nimport { AccordionTrigger, MeasurementTable, ScrollArea, useViewportGrid } from '@ohif/ui-next';\nimport {\n  PanelMeasurement,\n  StudyMeasurements,\n  StudySummaryFromMetadata,\n  AccordionGroup,\n  StudyMeasurementsActions,\n  MeasurementsOrAdditionalFindings,\n} from '@ohif/extension-cornerstone';\n\nimport { useTrackedMeasurements } from '../getContextModule';\nimport { UntrackSeriesModal } from './PanelStudyBrowserTracking/untrackSeriesModal';\n\nconst { filterAnd, filterPlanarMeasurement, filterMeasurementsBySeriesUID } =\n  utils.MeasurementFilters;\n\nfunction PanelMeasurementTableTracking(props) {\n  const [viewportGrid] = useViewportGrid();\n  const { servicesManager } = useSystem();\n  const { measurementService, uiModalService } = servicesManager.services;\n\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\n  const { trackedStudy, trackedSeries } = trackedMeasurements.context;\n  const measurementFilter = trackedStudy\n    ? filterAnd(filterPlanarMeasurement, filterMeasurementsBySeriesUID(trackedSeries))\n    : filterPlanarMeasurement;\n\n  const onUntrackConfirm = () => {\n    sendTrackedMeasurementsEvent('UNTRACK_ALL', {});\n  };\n\n  const onDelete = () => {\n    const hasDirtyMeasurements = measurementService\n      .getMeasurements()\n      .some(measurement => measurement.isDirty);\n    hasDirtyMeasurements\n      ? uiModalService.show({\n          title: 'Untrack Study',\n          content: UntrackSeriesModal,\n          contentProps: {\n            onConfirm: onUntrackConfirm,\n            message: 'Are you sure you want to untrack study and delete all measurements?',\n          },\n        })\n      : onUntrackConfirm();\n  };\n\n  const EmptyComponent = () => (\n    <div data-cy=\"trackedMeasurements-panel\">\n      <MeasurementTable\n        title=\"Measurements\"\n        isExpanded={false}\n      >\n        <MeasurementTable.Body />\n      </MeasurementTable>\n    </div>\n  );\n\n  const actions = {\n    createSR: ({ StudyInstanceUID }) => {\n      sendTrackedMeasurementsEvent('SAVE_REPORT', {\n        viewportId: viewportGrid.activeViewportId,\n        isBackupSave: true,\n        StudyInstanceUID,\n        measurementFilter,\n      });\n    },\n    onDelete,\n  };\n\n  const Header = props => (\n    <AccordionTrigger\n      asChild={true}\n      className=\"px-0\"\n    >\n      <div data-cy=\"TrackingHeader\">\n        <StudySummaryFromMetadata\n          {...props}\n          actions={actions}\n        />\n      </div>\n    </AccordionTrigger>\n  );\n\n  return (\n    <ScrollArea>\n      <div data-cy=\"trackedMeasurements-panel\">\n        <PanelMeasurement\n          measurementFilter={measurementFilter}\n          emptyComponent={EmptyComponent}\n          sourceChildren={props.children}\n        >\n          <StudyMeasurements grouping={props.grouping}>\n            <AccordionGroup.Trigger\n              key=\"trackingMeasurementsHeader\"\n              asChild={true}\n            >\n              <Header key=\"trackingHeadChild\" />\n            </AccordionGroup.Trigger>\n            <MeasurementsOrAdditionalFindings\n              key=\"measurementsOrAdditionalFindings\"\n              activeStudyUID={trackedStudy}\n              customHeader={StudyMeasurementsActions}\n              measurementFilter={measurementFilter}\n              actions={actions}\n            />\n          </StudyMeasurements>\n        </PanelMeasurement>\n      </div>\n    </ScrollArea>\n  );\n}\n\nexport default PanelMeasurementTableTracking;\n","import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { useSystem } from '@ohif/core';\nimport PanelStudyBrowser from '@ohif/extension-default/src/Panels/StudyBrowser/PanelStudyBrowser';\nimport { UntrackSeriesModal } from './untrackSeriesModal';\nimport { useTrackedMeasurements } from '../../getContextModule';\n\nconst thumbnailNoImageModalities = ['SR', 'SEG', 'RTSTRUCT', 'RTPLAN', 'RTDOSE', 'PMAP'];\n\n/**\n * Panel component for the Study Browser with tracking capabilities\n */\nexport default function PanelStudyBrowserTracking({\n  getImageSrc,\n  getStudiesForPatientByMRN,\n  requestDisplaySetCreationForStudy,\n  dataSource,\n}) {\n  const { servicesManager } = useSystem();\n  const { displaySetService, uiModalService, measurementService, viewportGridService } =\n    servicesManager.services;\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\n  const { trackedSeries } = trackedMeasurements.context;\n\n  const checkDirtyMeasurements = displaySetInstanceUID => {\n    const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n    if (displaySet.Modality === 'SR') {\n      const activeViewportId = viewportGridService.getActiveViewportId();\n      sendTrackedMeasurementsEvent('CHECK_DIRTY', {\n        viewportId: activeViewportId,\n        displaySetInstanceUID: displaySetInstanceUID,\n      });\n    }\n  };\n\n  useEffect(() => {\n    const subscriptionOndropFired = viewportGridService.subscribe(\n      viewportGridService.EVENTS.VIEWPORT_ONDROP_HANDLED,\n      ({ eventData }) => {\n        checkDirtyMeasurements(eventData.displaySetInstanceUID);\n      }\n    );\n\n    return () => {\n      subscriptionOndropFired.unsubscribe();\n    };\n  }, []);\n  const onClickUntrack = displaySetInstanceUID => {\n    const onConfirm = () => {\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n      sendTrackedMeasurementsEvent('UNTRACK_SERIES', {\n        SeriesInstanceUID: displaySet.SeriesInstanceUID,\n      });\n      const measurements = measurementService.getMeasurements();\n      measurements.forEach(m => {\n        if (m.referenceSeriesUID === displaySet.SeriesInstanceUID) {\n          measurementService.remove(m.uid);\n        }\n      });\n    };\n\n    uiModalService.show({\n      title: 'Untrack Series',\n      content: UntrackSeriesModal,\n      contentProps: {\n        onConfirm,\n        message: 'Are you sure you want to untrack this series?',\n      },\n    });\n  };\n\n  // Custom mapping function to add tracking data to display sets\n  const mapDisplaySetsWithTracking = (\n    displaySets,\n    displaySetLoadingState,\n    thumbnailImageSrcMap,\n    viewports\n  ) => {\n    const thumbnailDisplaySets = [];\n    const thumbnailNoImageDisplaySets = [];\n    displaySets\n      .filter(ds => !ds.excludeFromThumbnailBrowser)\n      .forEach(ds => {\n        const { thumbnailSrc, displaySetInstanceUID } = ds;\n        const componentType = getComponentType(ds);\n\n        const array =\n          componentType === 'thumbnailTracked' ? thumbnailDisplaySets : thumbnailNoImageDisplaySets;\n\n        const loadingProgress = displaySetLoadingState?.[displaySetInstanceUID];\n\n        array.push({\n          displaySetInstanceUID,\n          description: ds.SeriesDescription || '',\n          seriesNumber: ds.SeriesNumber,\n          modality: ds.Modality,\n          seriesDate: ds.SeriesDate ? new Date(ds.SeriesDate).toLocaleDateString() : '',\n          numInstances: ds.numImageFrames,\n          loadingProgress,\n          countIcon: ds.countIcon,\n          messages: ds.messages,\n          StudyInstanceUID: ds.StudyInstanceUID,\n          componentType,\n          imageSrc: thumbnailSrc || thumbnailImageSrcMap[displaySetInstanceUID],\n          dragData: {\n            type: 'displayset',\n            displaySetInstanceUID,\n          },\n          isTracked: trackedSeries.includes(ds.SeriesInstanceUID),\n          isHydratedForDerivedDisplaySet: ds.isHydrated,\n        });\n      });\n\n    return [...thumbnailDisplaySets, ...thumbnailNoImageDisplaySets];\n  };\n\n  // Override component type to use tracking specific components\n  const getComponentType = ds => {\n    if (\n      thumbnailNoImageModalities.includes(ds.Modality) ||\n      ds.unsupported ||\n      ds.thumbnailSrc === null\n    ) {\n      return 'thumbnailNoImage';\n    }\n    return 'thumbnailTracked';\n  };\n\n  return (\n    <PanelStudyBrowser\n      getImageSrc={getImageSrc}\n      getStudiesForPatientByMRN={getStudiesForPatientByMRN}\n      requestDisplaySetCreationForStudy={requestDisplaySetCreationForStudy}\n      dataSource={dataSource}\n      customMapDisplaySets={mapDisplaySetsWithTracking}\n      onClickUntrack={onClickUntrack}\n      onDoubleClickThumbnailHandlerCallBack={checkDirtyMeasurements}\n    />\n  );\n}\n\nPanelStudyBrowserTracking.propTypes = {\n  dataSource: PropTypes.shape({\n    getImageIdsForDisplaySet: PropTypes.func.isRequired,\n  }).isRequired,\n  getImageSrc: PropTypes.func.isRequired,\n  getStudiesForPatientByMRN: PropTypes.func.isRequired,\n  requestDisplaySetCreationForStudy: PropTypes.func.isRequired,\n};\n","/**\n * @param {*} cornerstone\n * @param {*} imageId\n */\nfunction getImageSrcFromImageId(cornerstone, imageId) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    cornerstone.utilities\n      .loadImageToCanvas({ canvas, imageId, thumbnail: true })\n      .then(imageId => {\n        resolve(canvas.toDataURL());\n      })\n      .catch(reject);\n  });\n}\n\nexport default getImageSrcFromImageId;\n","import React, { useCallback } from 'react';\n//\nimport PanelStudyBrowserTracking from './PanelStudyBrowserTracking';\nimport getImageSrcFromImageId from './getImageSrcFromImageId';\nimport { requestDisplaySetCreationForStudy } from '@ohif/extension-default';\nimport { useSystem } from '@ohif/core';\n\nfunction _getStudyForPatientUtility(extensionManager) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-default.utilityModule.common'\n  );\n\n  const { getStudiesForPatientByMRN } = utilityModule.exports;\n  return getStudiesForPatientByMRN;\n}\n\n/**\n * Wraps the PanelStudyBrowser and provides features afforded by managers/services\n *\n * @param {object} params\n * @param {object} commandsManager\n * @param {object} extensionManager\n */\nfunction WrappedPanelStudyBrowserTracking() {\n  const { extensionManager } = useSystem();\n  const dataSource = extensionManager.getActiveDataSource()[0];\n\n  const getStudiesForPatientByMRN = _getStudyForPatientUtility(extensionManager);\n  const _getStudiesForPatientByMRN = getStudiesForPatientByMRN.bind(null, dataSource);\n  const _getImageSrcFromImageId = useCallback(\n    _createGetImageSrcFromImageIdFn(extensionManager),\n    []\n  );\n  const _requestDisplaySetCreationForStudy = requestDisplaySetCreationForStudy.bind(\n    null,\n    dataSource\n  );\n\n  return (\n    <PanelStudyBrowserTracking\n      dataSource={dataSource}\n      getImageSrc={_getImageSrcFromImageId}\n      getStudiesForPatientByMRN={_getStudiesForPatientByMRN}\n      requestDisplaySetCreationForStudy={_requestDisplaySetCreationForStudy}\n    />\n  );\n}\n\n/**\n * Grabs cornerstone library reference using a dependent command from\n * the @ohif/extension-cornerstone extension. Then creates a helper function\n * that can take an imageId and return an image src.\n *\n * @param {func} getCommand - CommandManager's getCommand method\n * @returns {func} getImageSrcFromImageId - A utility function powered by\n * cornerstone\n */\nfunction _createGetImageSrcFromImageIdFn(extensionManager) {\n  const utilities = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  try {\n    const { cornerstone } = utilities.exports.getCornerstoneLibraries();\n    return getImageSrcFromImageId.bind(null, cornerstone);\n  } catch (ex) {\n    throw new Error('Required command not found');\n  }\n}\n\nexport default WrappedPanelStudyBrowserTracking;\n","import React from 'react';\nimport { FooterAction } from '@ohif/ui-next';\n\nexport function UntrackSeriesModal({ hide, onConfirm, message }) {\n  return (\n    <div className=\"text-foreground text-[13px]\">\n      <div>\n        <p>{message}</p>\n        <p className=\"mt-2\">\n          This action cannot be undone and will delete all your existing measurements.\n        </p>\n      </div>\n      <FooterAction className=\"mt-4\">\n        <FooterAction.Right>\n          <FooterAction.Secondary onClick={hide}>Cancel</FooterAction.Secondary>\n          <FooterAction.Primary\n            onClick={() => {\n              onConfirm();\n              hide();\n            }}\n          >\n            Untrack\n          </FooterAction.Primary>\n        </FooterAction.Right>\n      </FooterAction>\n    </div>\n  );\n}\n","import PanelStudyBrowserTracking from './PanelStudyBrowserTracking';\nimport PanelMeasurementTableTracking from './PanelMeasurementTableTracking';\n\nexport { PanelMeasurementTableTracking, PanelStudyBrowserTracking };\n","import { PubSubService } from '@ohif/core';\n\nconst EVENTS = {\n  TRACKED_SERIES_CHANGED: 'event::trackedmeasurements:trackedserieschanged',\n  SERIES_ADDED: 'event::trackedmeasurements:seriesadded',\n  SERIES_REMOVED: 'event::trackedmeasurements:seriesremoved',\n  TRACKING_ENABLED: 'event::trackedmeasurements:trackingenabled',\n  TRACKING_DISABLED: 'event::trackedmeasurements:trackingdisabled',\n};\n\n/**\n * Service class for accessing tracked measurements data.\n * This service provides a robust way to access tracked series information\n * from anywhere in the application, including outside of React components.\n */\nexport class TrackedMeasurementsService extends PubSubService {\n  public static readonly REGISTRATION = {\n    name: 'trackedMeasurementsService',\n    altName: 'TrackedMeasurementsService',\n    create: ({ configuration = {} }) => {\n      return new TrackedMeasurementsService();\n    },\n  };\n\n  private _trackedSeries: string[] = [];\n\n  constructor() {\n    super(EVENTS);\n  }\n\n  /**\n   * Updates the tracked series and notifies subscribers\n   * @param trackedSeries Array of series UIDs being tracked\n   */\n  public updateTrackedSeries(trackedSeries: string[]): void {\n    if (!trackedSeries) {\n      trackedSeries = [];\n    }\n\n    const hasChanged =\n      this._trackedSeries.length !== trackedSeries.length ||\n      this._trackedSeries.some((seriesUID, index) => seriesUID !== trackedSeries[index]);\n\n    if (hasChanged) {\n      const oldSeries = [...this._trackedSeries];\n      this._trackedSeries = [...trackedSeries];\n\n      const wasEmpty = oldSeries.length === 0;\n      const isEmpty = trackedSeries.length === 0;\n\n      if (wasEmpty && !isEmpty) {\n        this._broadcastEvent(EVENTS.TRACKING_ENABLED, {\n          trackedSeries: this.getTrackedSeries(),\n        });\n      } else if (!wasEmpty && isEmpty) {\n        this._broadcastEvent(EVENTS.TRACKING_DISABLED, {\n          trackedSeries: this.getTrackedSeries(),\n        });\n      }\n\n      this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n        trackedSeries: this.getTrackedSeries(),\n      });\n    }\n  }\n\n  /**\n   * Adds a single series to tracking\n   * @param seriesInstanceUID Series instance UID to add to tracking\n   */\n  public addTrackedSeries(seriesInstanceUID: string): void {\n    if (!seriesInstanceUID || this.isSeriesTracked(seriesInstanceUID)) {\n      return;\n    }\n\n    const wasEmpty = this._trackedSeries.length === 0;\n    this._trackedSeries = [...this._trackedSeries, seriesInstanceUID];\n\n    this._broadcastEvent(EVENTS.SERIES_ADDED, {\n      seriesInstanceUID,\n      trackedSeries: this.getTrackedSeries(),\n    });\n\n    if (wasEmpty) {\n      this._broadcastEvent(EVENTS.TRACKING_ENABLED, {\n        trackedSeries: this.getTrackedSeries(),\n      });\n    }\n\n    this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n      trackedSeries: this.getTrackedSeries(),\n    });\n  }\n\n  /**\n   * Removes a single series from tracking\n   * @param seriesInstanceUID Series instance UID to remove from tracking\n   */\n  public removeTrackedSeries(seriesInstanceUID: string): void {\n    if (!seriesInstanceUID || !this.isSeriesTracked(seriesInstanceUID)) {\n      return;\n    }\n\n    this._trackedSeries = this._trackedSeries.filter(uid => uid !== seriesInstanceUID);\n\n    this._broadcastEvent(EVENTS.SERIES_REMOVED, {\n      seriesInstanceUID,\n      trackedSeries: this.getTrackedSeries(),\n    });\n\n    if (this._trackedSeries.length === 0) {\n      this._broadcastEvent(EVENTS.TRACKING_DISABLED, {\n        trackedSeries: this.getTrackedSeries(),\n      });\n    }\n\n    this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n      trackedSeries: this.getTrackedSeries(),\n    });\n  }\n\n  /**\n   * Retrieves the currently tracked series\n   * @returns Array of series UIDs being tracked\n   */\n  public getTrackedSeries(): string[] {\n    return [...this._trackedSeries];\n  }\n\n  /**\n   * Checks if a specific series is being tracked\n   * @param seriesInstanceUID Series instance UID to check\n   * @returns boolean indicating if series is tracked\n   */\n  public isSeriesTracked(seriesInstanceUID: string): boolean {\n    return this._trackedSeries.includes(seriesInstanceUID);\n  }\n\n  /**\n   * Resets the service state\n   */\n  public reset(): void {\n    const wasTracking = this._trackedSeries.length > 0;\n    this._trackedSeries = [];\n\n    if (wasTracking) {\n      this._broadcastEvent(EVENTS.TRACKING_DISABLED, {\n        trackedSeries: [],\n      });\n\n      this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n        trackedSeries: [],\n      });\n    }\n\n    super.reset();\n  }\n\n  /**\n   * Checks if any series are being tracked\n   * @returns boolean indicating if tracking is active\n   */\n  public isTrackingEnabled(): boolean {\n    return this._trackedSeries.length > 0;\n  }\n}\n\nexport default TrackedMeasurementsService;\n","export * from './TrackedMeasurementsService';\n","export * from './TrackedMeasurementsService';\n","export * from './AppTypes';\n"],"names":[],"sourceRoot":""}